## 前端状态管理

前端状态管理指用于管理 view 层相关的 state 的思想和方法。

### Flux

将各个组件修改数据层的`controller`统一管理。组件需要修改数据层的话需要用`Actions`去触发预先定义好的`dispatcher`，然后`dispatcher`应用到`model`上，实现数据层的修改。然后数据层的修改会映射到视图上，形成一个单向的数据流。
![Flux](https://www.w3cplus.com/sites/default/files/blogs/2017/1708/state-4.png)

好处：单向数据流可以避免复杂应用下的多来源数据造成混乱。

<center>官方实现</center>

![Flux](https://www.w3cplus.com/sites/default/files/blogs/2017/1708/state-5.png)

### reflux
去掉了显式的 Dispatcher，将 action 表现为函数的形式。
![reflux](https://www.w3cplus.com/sites/default/files/blogs/2017/1708/state-6.png)
```javascript
const addBook = Reflux.createAction({ 
  actionName: 'add-book', 
  sync: false, 
  preEmit: function() {/*...*/}, 
  // ... 
})
```
### Redux
`Redux`去掉了`Dispatcher`，用纯函数`reducer`代替。

特点：
1. 不会原地修改state，而是用新的state去替换
2. 全局只有一个store
3. 不会直接对数据层进行修改，而是用一个`Action`来描述 
![Redux](https://www.w3cplus.com/sites/default/files/blogs/2017/1708/state-7.png)
#### redux-thunk

#### redux-saga

### Vuex
`Vuex`与`Redux`很像。不过`Vue`中的state可以被修改，这是因为`Vue`是基于ES5的`getter/setter`机制来实现视图与数据的双向绑定。因此`Vuex`中state的变更可以通知视图进行更新。
`mutation`必须是同步函数，`action`可以包含异步操作
```javascript
const actions = { 
  addBook({ commit }) { 
    request
    .get(BOOK_API)
    .then(res => commit(ADD_BOOK, res.body.new_book)) 
  } 
}
```
### mobx
![mobx](https://www.w3cplus.com/sites/default/files/blogs/2017/1708/state-9.png)

+ `Observable`：它的 state 是可被观察的，无论是基本数据类型还是引用数据类型，都可以使用 MobX 的 (@)observable 来转变为 observable value。
+ `Reactions`：它包含不同的概念，基于被观察数据的更新导致某个计算值（computed values），或者是发送网络请求以及更新视图等，都属于响应的范畴，这也是响应式编程（Reactive Programming）在 JavaScript 中的一个应用。
+ `Actions`：它相当于所有响应的源头，例如用户在视图上的操作，或是某个网络请求的响应导致的被观察数据的变更。

### 单向绑定与双向绑定
单向数据绑定：view层不可以直接修改数据层，需要通知或其他机制来通知数据层修改相应的数据。

双向数据绑定：view层可以直接修改数据层，数据层变化导致view层变化

单向绑定：
+ 带来单向数据流，这样做的好处是所有状态变化都可以被记录、跟踪，状态变化通过手动调用通知，源头易追溯，没有“暗箱操作”。
+ 组件数据只有唯一的入口和出口，使得程序更直观更容易理解，有利于应用的可维护性。
+ 缺点则是代码量会相应的上升，数据的流转过程变长，从而出现很多类似的样板代码。同时由于对应用状态独立管理的严格要求(单一的全局store)，在处理局部状态较多的场景时(如用户输入交互较多的“富表单型”应用)，会显得啰嗦及繁琐。

双向绑定：
+ 优点是在表单交互较多的场景下，会简化大量业务无关的代码。
+ 缺点就是由于都是“暗箱操作”，我们无法追踪局部状态的变化(虽然大部分情况下我们并不关心)，潜在的行为太多也增加了出错时 debug 的难度。同时由于组件数据变化来源入口变得可能不止一个，新手玩家很容易将数据流转方向弄得紊乱，如果再缺乏一些“管制”手段，最后就很容易因为一处错误操作造成应用雪崩。
