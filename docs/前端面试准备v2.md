# 前端面试准备

## CSS

### BFC

在BFC中，每一个元素**左外边**与**包含块的左边**相接触（对于从右到左的格式化，右外边接触右边）

即使存在浮动也是如此（所以浮动元素正常会直接贴近它的包含块的左边，与普通元素重合），除非这个元素也创建了一个新的BFC。特点如下

1. 内部`box`在垂直方向，一个接一个的放置
2. box的垂直方向由`margin`决定，属于同一个BFC的两个box间的margin会重叠
3. BFC区域不会与`float box`重叠（可用于排版)
4. BFC就是页面上的一个隔离的独立容器，容器里面的子元素不会影响到外面的元素。反之也如此
5. 计算BFC的高度时，浮动元素也参与计算（不会浮动坍塌）

如何触发？

1. 根元素
2. `float`属性不为`none`
3. `position`为`absolute`或`fixed`
4. `display`为`inline-block`, `flex`, `inline-flex`，`table`，`table-cell`，`table-caption`
5. `overflow`不为`visible`

### IFC

行内元素自身如何显示以及在框内如何摆放 。

1. 如果几个行内框在水平方向无法放入一个行框内，它们可以分配在两个或多个垂直堆叠的行框中（即行内框的分割）
2. 行框在堆叠时没有垂直方向上的分割且永不重叠
3. 行框的高度总是足够容纳所包含的所有框。不过，它可能高于它包含的最高的框（例如，框对齐会引起基线对齐）
4. 行框的左边接触到其包含块的左边，右边接触到其包含块的右边。


## JS

### 引擎运行

**核心的JIT编译器将源码编译成机器码运行**。

词法分析-> 语法分析-> 字节码->机器码

字节码只在运行时编译，用到哪一行就编译哪一行，并且缓存(inline cache)

### 数据类型

**原始类型**：number、string、boolean、null、undefined、symbol(ES6新增)

**对象类型**：object(array，function)

原始类型不可变，对象类型可变。

对象类型具有属性；在使用string、number、boolean原始类型方法时，js会在调用new String()等方式将string、number、boolean转成对应的对象，从而进行属性的引用。但如果给string类型添加属性，js会忽略并返回undefined。


## ES6

### let const

`let`声明的变量必须在声明后使用，不存在变量提升。

`let`声明的变量会绑定在作用域中，不受外界变量影响，在声明之前变量不可用。

**块级作用域**

外层作用域无法读取内层作用域的变量。

内层作用域可以定义外层作用域的同名变量 。

块级作用域之中，函数声明语句的行为类似于`let`，在块级作用域之外不可引用 

### 函数

默认参数，惰性求值

指定了默认值以后，函数的`length`属性，将返回没有指定默认值的参数个数，如果设置了默认值的参数不是尾参数，那么`length`属性也不再计入后面的参数了。

设置了参数的默认值，函数进行声明初始化时，参数会形成一个单独的作用域。

`rest`（...变量名），代替arguments

### 箭头函数

非箭头函数有自己的`this`，箭头函数没有自己的`this`，而是从自己的作用域链的上一层继承`this`。

由于 箭头函数没有自己的`this`，通过 `call` *或* `apply` 方法调用一个函数时，只能传递参数，第一个参数会被忽略。

### 扩展运算符(...)

将一个数组转为用逗号分隔的**参数序列**。

```javascript
Math.max(...[14, 3, 77])
// 等同于
Math.max(14, 3, 77);
list=[1,2,3]
[a, ...rest] = list // a=1 rest=[2,3]
```

### 可枚举

目前，有四个操作会忽略`enumerable`为`false`的属性。

+ `for...in`循环：只遍历对象自身的和继承的可枚举的属性。
+ `Object.keys()`：返回对象自身的所有可枚举的属性的键名。
+ `JSON.stringify()`：只串行化对象自身的可枚举的属性。
+ `Object.assign()`： 忽略`enumerable`为`false`的属性，只拷贝对象自身的可枚举的属性。

## 框架

### React
### Vue
### PWA

+ serviceworker：实现通知功能
+ cacheStorage || indexedDB：实现页面缓存和骨架屏
+ mainfiest.json： 实现桌面图标

## 移动端

### viewport

dp：设备像素即物理像素，与屏幕有关。设备中实际使用的像素 

px：虚拟像素，在css代码中用到的逻辑像素

1px = (dpr)^2 * 1dp 





## 状态管理

Flux,Reflux,Redux,Vuex,Mobx 介绍和比较可以参考本文

[浅谈前端状态管理](https://www.w3cplus.com/javascript/talk-about-front-end-state-management.html)


## 进程与线程

+ 进程是cpu资源分配的最小单位（是能拥有资源和独立运行的最小单位）
+ 线程是cpu调度的最小单位（线程是建立在进程的基础上的一次程序运行单位，一个进程中可以有多个线程

## 测试

1. 明确测试目的
2. 并发用户数
3. 最耗资源的功能
4. 最频繁使用功能和访问的页面
5. 网络、设备因素
6. 一些压力测试工具
7. js 功能测试：Jtest ，snapshot 快照测试
8. 组件：storybook

## 安全

+ React 会对字符进行转译替换成字符串，从而保证了安全性

## 例题

### css加载是否会阻塞dom树渲染？

**css是由单独的下载线程异步下载的** 

css加载不会阻塞DOM树解析（异步加载时DOM照常构建），但会阻塞render树渲染（渲染时需等css加载完毕，因为render树需要css信息）

### 从输入URL到页面加载的过程？

[参考](http://www.dailichun.com/2018/03/12/whenyouenteraurl.html)

```
1. 从浏览器接收url到开启网络请求线程（这一部分可以展开浏览器的机制以及进程与线程之间的关系）

2. 开启网络线程到发出一个完整的http请求（这一部分涉及到dns查询，tcp/ip请求，五层因特网协议栈等知识）

3. 从服务器接收到请求到对应后台接收到请求（这一部分可能涉及到负载均衡，安全拦截以及后台内部的处理等等）

4. 后台和前台的http交互（这一部分包括http头部、响应码、报文结构、cookie等知识，可以提下静态资源的cookie优化，以及编码解码，如gzip压缩等）

5. 单独拎出来的缓存问题，http的缓存（这部分包括http缓存头部，etag，catch-control等）

6. 浏览器接收到http数据包后的解析流程（解析html-词法分析然后解析成dom树、解析css生成css规则树、合并成render树，然后layout、painting渲染、复合图层的合成、GPU绘制、外链资源的处理、loaded和domcontentloaded等）

7. CSS的可视化格式模型（元素的渲染规则，如包含块，控制框，BFC，IFC等概念）

8. JS引擎解析过程（JS的解释阶段，预处理阶段，执行阶段生成执行上下文，VO，作用域链、回收机制等等）

9. 其它（可以拓展不同的知识模块，如跨域，web安全，hybrid模式等等内容）
```

### visibility: hidden和display: none的区别

+ 普通回答，一个隐藏，但占据位置，一个隐藏，不占据位置
+ 进一步，`display`由于隐藏后不占据位置，所以造成了dom树的改变，会引发回流，代价较大
+ 再进一步，当一个页面某个元素经常需要切换`display`时如何优化，一般会用复合层优化，或者要求低一点用`absolute`让其脱离普通文档流也行。然后可以将话题引到普通文档流，`absolute`文档流，复合图层的区别，
+ 再进一步可以描述下浏览器渲染原理以及复合图层和普通图层的绘制区别（复合图层单独分配资源，独立绘制，性能提升，但是不能过多，还有隐式合成等等）

### 洗牌算法

+ `1-N`存储在列表list中，当前索引为index=N
+ 随机生成一个数字k(1到index(包括这个数字))
+ 交换第k为和第index位元素的值
+ index–
+ 如果index到了最后一位(1)，则退出循环，这时候list已经被随机排序了，完成算法

### this相关

```javascript
var adder = {
  base : 1,
    
  add : function(a) {
    var f = v => v + this.base;
    return f(a);
  },

  addThruCall: function(a) {
    var f = v => v + this.base;
    var b = {
      base : 2
    };
            
    return f.call(b, a);
  }
};

console.log(adder.add(1));         // 输出 2
console.log(adder.addThruCall(1)); // 输出 2
```

### 尾递归相关

函数调用自身，称为递归。如果尾调用自身，就称为尾递归。 尾部调用函数会进行优化。

阶乘

```javascript
function factorial(n, total) {
  if (n === 1) return total;
  return factorial(n - 1, n * total);
}
```

 斐波那契数列

```javascript
function Fibonacci2 (n , ac1 = 1 , ac2 = 1) {
  if( n <= 1 ) {return ac2};

  return Fibonacci2 (n - 1, ac2, ac1 + ac2);
}
```