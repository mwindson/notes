# 例题

## css 加载是否会阻塞 dom 树渲染？

**css 是由单独的下载线程异步下载的**

css 加载不会阻塞 DOM 树解析（异步加载时 DOM 照常构建），但会阻塞 render 树渲染（渲染时需等 css 加载完毕，因为 render 树需要 css 信息）

## 从输入 URL 到页面加载的过程？

[参考](http://www.dailichun.com/2018/03/12/whenyouenteraurl.html)

1.  从浏览器接收 url 到开启网络请求线程（这一部分可以展开浏览器的机制以及进程与线程之间的关系）

    - 多进程的浏览器
    - 多线程的浏览器内核
    - 解析 URL
    - 网络请求都是单独的线程
      每次网络请求时都需要开辟单独的线程进行，譬如如果 URL 解析到 http 协议，就会新建一个网络线程去处理资源下载

2.  开启网络线程到发出一个完整的 http 请求（这一部分涉及到 dns 查询，tcp/ip 请求，五层因特网协议栈等知识）
    - DNS 查询得到 IP
      - 如果浏览器有缓存，直接使用浏览器缓存，否则使用本机缓存，再没有的话就是用 host
      - 如果本地没有，就向 dns 域名服务器查询（当然，中间可能还会经过路由，也有缓存等），查询到对应的 IP
    - tcp/ip 请求
      - 三次握手建立连接
      - 四次挥手断开连接
    - 五层因特网协议栈
3.  从服务器接收到请求到对应后台接收到请求（这一部分可能涉及到负载均衡，安全拦截以及后台内部的处理等等）

    - 负载均衡
    - 后台的处理

4.  后台和前台的 http 交互（这一部分包括 http 头部、响应码、报文结构、cookie 等知识，可以提下静态资源的 cookie 优化，以及编码解码，如 gzip 压缩等）
    - http 报文结构
    - cookie 以及优化
    - gzip 压缩
    - 长连接与短连接
    - http 2.0
    - https
5.  单独拎出来的缓存问题，http 的缓存（这部分包括 http 缓存头部，etag，catch-control 等）
    - 强缓存与弱缓存
    - 缓存头部简述
    - 头部的区别
6.  浏览器接收到 http 数据包后的解析流程（解析 html-词法分析然后解析成 dom 树、解析 css 生成 css 规则树、合并成 render 树，然后 layout、painting 渲染、复合图层的合成、GPU 绘制、外链资源的处理、loaded 和 domcontentloaded 等）

    - HTML 解析，构建 DOM
    - 生成 CSS 规则
    - 构建渲染树
    - 渲染
    - 简单层与复合层

7.  CSS 的可视化格式模型（元素的渲染规则，如包含块，控制框，BFC，IFC 等概念）
    - 包含块（Containing Block）
    - 控制框（Controlling Box）
    - BFC（Block Formatting Context）
    - IFC（Inline Formatting Context）
8.  JS 引擎解析过程（JS 的解释阶段，预处理阶段，执行阶段生成执行上下文，VO，作用域链、回收机制等等）
    - JS 的解释阶段
    - JS 的预处理阶段
    - JS 的执行阶段
    - 回收机制
9.  其它（可以拓展不同的知识模块，如跨域，web 安全，hybrid 模式等等内容）

## this 相关

```javascript
var adder = {
  base: 1,

  add: function(a) {
    var f = v => v + this.base
    return f(a)
  },

  addThruCall: function(a) {
    var f = v => v + this.base
    var b = {
      base: 2
    }

    return f.call(b, a)
  }
}

console.log(adder.add(1)) // 输出 2
console.log(adder.addThruCall(1)) // 输出 2
```

## 洗牌算法

- `1-N`存储在列表 list 中，当前索引为 index=N
- 随机生成一个数字 k(1 到 index(包括这个数字))
- 交换第 k 为和第 index 位元素的值
- index–
- 如果 index 到了最后一位(1)，则退出循环，这时候 list 已经被随机排序了，完成算法

## 尾递归相关

函数调用自身，称为递归。如果尾调用自身，就称为尾递归。 尾部调用函数会进行优化。

```javascript
// 阶乘
function factorial(n, total) {
  if (n === 1) return total
  return factorial(n - 1, n * total)
}
```

```javascript
// 斐波那契数列
function Fibonacci2(n, ac1 = 1, ac2 = 1) {
  if (n <= 1) {
    return ac2
  }

  return Fibonacci2(n - 1, ac2, ac1 + ac2)
}
```

## ([“1”,”2”,”3”]).map(parseInt)

[1,NaN,NaN]
因为 parseInt 有两个参数，number 和 radix，map 会把数组的 index 作为 radix 传入，当 number 大于 radix 会成为 NaN

## 同时发送几个请求，但是需要等到所有请求结束再执行回调？

promise.all()
如果请求会出错，可以将请求进行进一步的封装

```javascript
newFetch = fetch(...args)
  .then(res => ({ ok: true, res }))
  .catch(err => ({ ok: false, err }))
```

## 对数组[1,2,3,4,5,'6',7,'8','a','b','z']进行乱序

```javascript
let tempArr = [1, 2, 3, 4, 5, '6', 7, '8', 'a', 'b', 'z'].sort(function() {
  return Math.random() > 0.5
})
```
