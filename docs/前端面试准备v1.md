# 前端面试准备

### PWA

* serviceworker：实现通知功能
* cacheStorage || indexedDB：实现页面缓存和骨架屏
* mainfiest.json： 实现桌面图标

### HTML

* sessionStorage，localStroage可以跨页面，但不能跨域（必须来自同一域名，同一种协议，同一个端口）

  sessionStorage只保持在到浏览器关闭

* CDN网络是在用户和服务器之间增加Cache层，如何将用户的请求引导到Cache上获得源服务器的数据，主要是通过接管DNS实现。

  浏览器调用域名解析库对域名进行解析，由于CDN对域名解析过程进行了调整，所以解析函数库得到的是该域名对应的CNAME记录（由于现在已经是使用了CDN服务，CNAME为CDN服务商域名），为了得到实际IP地址，浏览器需要再次对获得的CNAME域名进行解析以得到实际的IP地址；在此过程中，使用的全局负载均衡DNS解析，如根据地理位置信息解析对应的IP地址，使得用户能就近访问。（CDN服务来提供最近的机器）

* `<script>`标签打开`defer`或`async`属性，脚本就会异步加载。渲染引擎遇到这一行命令，就会开始下载外部脚本，但不会等它下载和执行，而是直接执行后面的命令。

  `defer`与`async`的区别是：`defer`要等到整个页面在内存中正常渲染结束（DOM 结构完全生成，以及其他脚本执行完成），才会执行；`async`一旦下载完，渲染引擎就会中断渲染，执行这个脚本以后，再继续渲染。一句话，`defer`是“渲染完再执行”，`async`是“下载完就执行”。另外，如果有多个`defer`脚本，会按照它们在页面出现的顺序加载，而多个`async`脚本是不能保证加载顺序的。

* 缓存：(expires和cache-control返回200，last-modified/Etag返回304)

  * `Cache-Control` ：

    + `max-age `  秒为单位，会覆盖Expires
    + `Public`  指示响应可被**任何缓存区**缓存。
    + `Private`  指示对于单个用户的整个或部分响应消息，不能被共享缓存处理。这允许服务器仅仅描述当用户的部分响应消息，此响应消息对于其他用户的请求无效
    + `no-cache`  指示请求或响应消息不能缓存（HTTP/1.0用Pragma的no-cache替换）
    + `no-store`  表示必须先与服务器确认返回的响应是否发生了变化，然后才能使用该响应来满足后续对同一网址的请求。
    + `no-store` 不允许缓存响应，每次请求都必须完整获取。

  * `Expires`：指明过期的时间

  * `Last-Modified`：最后修改的时间

    客户端第二次请求此URL时，根据HTTP协议的规定，浏览器会向服务器传送**If-Modified-Since**报头(HttpRequest Header)，询问该时间之后文件是否有被修改过

  * `etag`：根据文件内容hash

    * 在客户端发出请求后，HttpReponse Header中包含Etag:“5d8c72a5edda8d6a:3239″标识，等于告诉Client端，你拿到的这个的资源有表示ID：5d8c72a5edda8d6a:3239。当下次需要发Request索要同一个URI的时候，浏览器同时发出一个**If-None-Match**报头(Http RequestHeader)此时包头中信息包含上次访问得到的Etag:“5d8c72a5edda8d6a:3239″标识。

    * 分布式系统里多台机器间文件的last-modified必须保持一致，以免负载均衡到不同机器导致比对失败分布式系统尽量关闭掉Etag(每台机器生成的etag都会不一样)

    If-None-Match为False，不返回200，返回304(Not Modified) Response。

  1. 判断`expires`，如果未过期，直接读取 http 缓存文件，不发 http 请求，否则进入下一步

  2. 判断是否含有`etag`，有则带上 `if-none-match` 发送请求，未修改返回 `304 not modified`，修改返回`200` ，否则进入下一步

  3. 判断是否含有 last-modified，有则带上 if-modified-since 发送请求，无效返回 200，有效返回 304，否则直接向服务器请求

     ![img](http://7tszky.com1.z0.glb.clouddn.com/FgtfwfAjs5EBAEIa9KFi25acNk7d)

### 跨域

  1. 主域相同可以设置 document.domain

     使用 document.domain 来允许子域安全访问其父域时，您需要在父域和子域中设置 document.domain 为相同的值

  2. script 可以跨域执行；动态创建 script，设置 js 的 callback，返回函数与参数（放置数据）

  3. iframe 和 location.hash

  4. window.name 实现的跨域数据传输

    name 值在不同的页面（甚至不同域名）加载后依旧存在，并且可以支持非常长的 name 值（2MB）

  5. 使用 HTML5 postMessage

    `otherWindow` : 对接收信息页面的 window 的引用。可以是页面中 iframe 的 contentWindow 属性；window.open 的返回值；通过 name 或下标从 window.frames 取到的值。

    `message` : 所要发送的数据，string 类型。

    `targetOrigin` : 用于限制 otherWindow，“\*”表示不作限制

  6. cors
      cors 的话,可控性较强,需要前后端都设置,兼容性 IE10+ ,比如

    Access-Control-Allow-Origin: http://foo.example // 子域乃至整个域名或所有域名是否允许访问

    Access-Control-Allow-Methods: POST, GET, OPTIONS // 允许那些行为方法

    Access-Control-Allow-Headers: X-PINGOTHER, Content-Type // 允许的头部字段

    Access-Control-Max-Age: 86400 // 有效期

  7. HTTP 请求

    HTTP/1.1 协议中共定义了 8 种 HTTP 请求方法，HTTP 请求方法也被叫做“请求动作”，不同的方法规定了不同的操作指定的资源方式。服务端也会根据不同的请求方法做不同的响应。

    **幂等：多次操作返回的结果相同**

    **GET**

    GET 请求会显示请求指定的资源。一般来说 GET 方法应该只用于数据的读取，而不应当用于会产生副作用的非幂等的操作中。
    GET 会方法请求指定的页面信息，并返回响应主体，GET 被认为是不安全的方法，因为 GET 方法会被网络蜘蛛等任意的访问。

    **HEAD**

    HEAD 方法与 GET 方法一样，都是向服务器发出指定资源的请求。但是，服务器在响应 HEAD 请求时不会回传资源的内容部分，即：响应主体。这样，我们可以不传输全部内容的情况下，就可以获取服务器的响应头信息。HEAD 方法常被用于客户端查看服务器的性能。

    **POST**

    POST 请求会 向指定资源提交数据，请求服务器进行处理，如：表单数据提交、文件上传等，请求数据会被包含在请求体中。POST 方法是非幂等的方法，因为这个请求可能会创建新的资源或/和修改现有资源。

    **PUT**
    PUT 请求会身向指定资源位置上传其最新内容，PUT 方法是幂等的方法。通过该方法客户端可以将指定资源的最新数据传送给服务器取代指定的资源的内容。

    **DELETE**
    DELETE 请求用于请求服务器删除所请求 URI（统一资源标识符，Uniform Resource Identifier）所标识的资源。DELETE 请求后指定资源会被删除，DELETE 方法也是幂等的。

    **CONNECT**
    CONNECT 方法是 HTTP/1.1 协议预留的，能够将连接改为管道方式的代理服务器。通常用于 SSL 加密服务器的链接与非加密的 HTTP 代理服务器的通信。

    **OPTIONS**
    OPTIONS 请求与 HEAD 类似，一般也是用于客户端查看服务器的性能。 这个方法会请求服务器返回该资源所支持的所有 HTTP 请求方法，该方法会用'\*'来代替资源名称，向服务器发送 OPTIONS 请求，可以测试服务器功能是否正常。JavaScript 的 XMLHttpRequest 对象进行 CORS 跨域资源共享时，就是使用 OPTIONS 方法发送嗅探请求，以判断是否有对指定资源的访问权限。 允许

    **TRACE**
    TRACE 请求服务器回显其收到的请求信息，该方法主要用于 HTTP 请求的测试或诊断。


### CSS

#### 盒子模型

W3C 盒子模型的范围包括 margin、border、padding、content，并且 content 部分不包含其他部分

IE 盒子模型的范围也包括 margin、border、padding、content，和标准 W3C 盒子模型不同的是：IE 盒子模型的 content 部分包含了 border 和 padding

#### BFC 

内部的 Box 会在垂直方向，一个接一个地放置。

Box 垂直方向的距离由 margin 决定。属于同一个 BFC 的两个相邻 Box 的 margin 会发生重叠

每个元素的 margin box 的左边， 与包含块 border box 的左边相接触(对于从左往右的格式化，否则相反)。即使存在浮动也是如此。

BFC 的区域不会与 float box 重叠。

BFC 就是页面上的一个隔离的独立容器，容器里面的子元素不会影响到外面的元素。反之也如此。

计算 BFC 的高度时，浮动元素也参与计算

**触发 BFC**

1.  根元素
2.  float 属性不为 none
3.  position 为 absolute 或 fixed
4.  display 为 inline-block, table-cell, table-caption, flex, inline-flex
5.  overflow 不为 visible

#### 伪类

* 状态 :link,:visited 等
* 结构化:not, :first-child, :nth-last-child
* 表单相关 :checked, :default,:disabled
* ...

#### 伪元素

::after , ::before , ::selection, :: first-line

#### [双栏、三栏布局](https://segmentfault.com/a/1190000009916931)

圣杯布局和双飞翼布局解决的问题是一样的，就是两边顶宽，中间自适应的三栏布局，中间栏要在放在文档流前面以优先渲染。

#### CSS 有哪些样式可以给子元素继承

* 可继承的:`font-size`,`font-weight`,`line-height`,`color`,`cursor`等
* 不可继承的一般是会改变盒子计算的:`display`,`margin`、`border`、`padding`、`height`等

#### CSS 中 transition 和 animate 有何区别? animate 如何停留在最后一帧

​    `transition`一般用来做过渡的,而`animate`则是做动效,算是前者的一个补充拓展；过渡的开销比动效小，
    如何让`animate`停留在最后一帧也好办,就它自身参数的一个值就可以了

```css
animation-fill-mode: forwards;  <!--backwards则停留在首帧,both是轮流-->
```
#### 样式权重的优先级;

!important > 行内样式 > id > class > tag

#### zoom和scale的区别

1. zoom的缩放是相对于左上角的；而scale默认是居中缩放；

2. zoom的缩放改变了元素占据的空间大小；而scale的缩放占据的原始尺寸不变，页面布局不会发生变化；

3. zoom会真实改变元素大小，会引起回流

   ​

### JS

#### null 与 undefined 区别

相同点:

+ 在 `if`判断语句中,值都默认为 `false`
+ 大体上两者都是代表**无**,具体看差异

差异:

+ `null`转为数字类型值为 0,而`undefined`转为数字类型为 `NaN(Not a Number)` (Number.parseInt()都是 NaN)
+ `undefined`是代表调用一个值而该值却没有赋值,这时候默认则为`undefined`
+ `null`是一个很特殊的对象,最为常见的一个用法就是作为参数传入(说明该参数不是对象)
+ 设置为`null`的变量或者对象会被内存收集器回收

* 非严格相等

  `ToNumber(A)` 尝试在比较前将参数 A 转换为数字，这与 +A（单目运算符+）的效果相同。`ToPrimitive(A)`通过尝试依次调用 A 的`A.toString()` 和 `A.valueOf()` 方法，将参数 A 转换为原始值（Primitive）

  ![52187529113](C:\Users\mwindson\AppData\Local\Temp\1521875291134.png)

  `falsy value` : 0 , NaN,"", false, null , undefined

#### jsonp

  ```
  /**
   * 获取随机字符串,用于拼接
   * @param {string} prefix [前导名字]
   * @param {number} num  [字符串长度]
   */
  function getRandomName (prefix, num) {
  	return prefix + Math.random().toString(36).replace(/[^a-z]+/g, '').substr(0, num)
  }

  /**
   * 创建script标签
   * @param {请求路径} url 
   */
  function createScript (url) {
  	const script = document.createElement('script')
  	script.setAttribute('type', 'text/javascript')
  	script.setAttribute('src', url)
  	script.async = true
  	return script
  }

  /**
   * 实现请求
   * @param {路径} url 
   */
  function jsonp (url) {
  	return new Promise((resolve, reject) => {
  		const cbName = getRandomName('callback')
  		window[cbName] = function (data) {
  			resolve(data)
  		}

  		url += url.indexOf('?') > -1 ? '&' : '?'
  		const script = createScript(`${url}callback=${cbName}`)

  		script.onload = function () {
  			script.onload = null
  			if (script.parentNode) {
  				script.parentNode.removeChild(script)
  			}
  			window[cbName] = null
  		}

  		script.onerror = function () {
  			reject()
  		}

  		document.getElementsByTagName('head')[0].appendChild(script)
  	})
  }
  ```

### ES6

`Array.from` 方法用于将两类对象转为真正的数组：类似数组的对象（array-like object）和可遍历（iterable）的对象（包括 ES6 新增的数据结构 Set 和 Map）

`Array.of`方法用于将一组值，转换为数组

* **es5 继承 (寄生组合继承)**

  ```javascript
  function ParentClass(name) {
    this.name = name
  }
  ParentClass.prototype.sayHello = function() {
    console.log("I'm parent!" + this.name)
  }
  function SubClass(name, age) {
    //  若是要多个参数可以用apply 结合 ...解构
    //  调用父类的构造函数
    ParentClass.call(this, name)
    this.age = age
  }
  SubClass.prototype = Object.create(ParentClass.prototype)
  SubClass.prototype.constructor = SubClass
  SubClass.prototype.sayChildHello = function(name) {
    console.log("I'm child " + this.name)
  }

  let testA = new SubClass('CRPER')
  ```

* **对数组[1,2,3,4,5,'6',7,'8','a','b','z']进行乱序**

  ```javascript
  let tempArr = [1, 2, 3, 4, 5, '6', 7, '8', 'a', 'b', 'z'].sort(function() {
    return Math.random() > 0.5
  })
  ```

* **静态方法**

  * 方法不能给 this 引用,可以给类直接引用
  * 静态不可以给实例调用,比如 `let a = new ParentClass => a.sayHello()` 会抛出异常
  * 父类静态方法,子类非`static`方法没法覆盖父类
  * 静态方法可以给子类继承
  * 静态属性可以继承也可以被修改

* **私有变量**

  * 人为命名区分
  * 利用闭包
  * weakMap 可以避免内存泄露,当没有被值引用的时候会自动给内存寄存器回收

* **Q: 谈谈你对 TCP 的理解;**
  挥手时发送报文表示自己不在发送数据，但扔接受数据

  > Q: TCP 是在哪个 OSI 的哪个层!通讯过程是全双工还是半双工(单工)?
  >
  > A: 传输层,全双工
  >
  > Q: TCP 的通讯的过程是怎么样的!
  >
  > A: 整个过程是三次握手,四次挥手..
  >
  > Q: 你说的没错,说说整个过程如何?
  >
  > A: 举个栗子,我把 TCP 比做两个人用对讲机沟通(大白话)..三次握手就是.A1(吼叫方,客户端)想要呼叫 A2(控制室的某某,服务端)..
  >
  > A1 对着对讲机说"over over ,听到请回答"(第一次,请求应答) ...
  >
  > A2 收到回应"收到收到,你说"(第二次,确认应答)
  >
  > A1 开始巴拉巴拉个不停而 A2 没拒绝(第三次,通讯建立)
  >
  > ---
  >
  > 而四次挥手则是两者确认互相倾述完毕的过程..
  >
  > A1 说:"控制室,报告完毕了"(第一次挥手)
  >
  > A2 说:"知道了...那么你废话说完就好好听我指挥....巴拉巴拉.."(第二次挥手)
  >
  > A1 此时等待控制室说完毕,而控制室等回应(第三次挥手)
  >
  > 等到 A1 回馈控制室确认都知道完毕了..(第四次挥手)...

  **为什么建立连接是三次握手，而关闭连接却是四次挥手呢？**

  这是因为服务端在 LISTEN 状态下，收到建立连接请求的 SYN 报文后，把 ACK 和 SYN 放在一个报文里发送给客户端。而关闭连接时，当收到对方的 FIN 报文时，仅仅表示对方不再发送数据了但是还能接收数据，己方也未必全部数据都发送给对方了，所以己方可以立即 close，也可以发送一些数据给对方后，再发送 FIN 报文给对方来表示同意现在关闭连接，因此，己方 ACK 和 FIN 一般都会分开发送。

* `OSI` 七层涵盖:物理层,数据链路层,网络层（IP）,传输层（TCP、UDP）,会话层,表示层,应用层（DNS，HTTP）;

* `DNS` 属于应用层协议

  1.  优先读取浏览器缓存
  2.  其次系统的缓存
  3.  都没有的情况下,找本地`hosts`文件(比如你写了映射关系优先寻找)
  4.  再没有的情况找最近的域名解析服务器
  5.  再没有则扩大访问,最终找到根服务器,还是没有就失败了..

* `HTTP`相对于 `HTTPS`来说,速度较快且开销较小(没有 SSL/TSL) 对接,默认是 80 端口;

  `HTTP`容易遭受域名劫持,而`HTTPS`相对来说就较为安全但开销较大(数据以加密的形式传递),默认端口为 443..

  `HTTP`是明文跑在 `TCP` 上.而`HTTPS`跑在`SSL/TLS`应用层之下,`TCP`上的

  `HTTP`2.0 的变化：

  * 多路复用：允许同时通过单一的 HTTP/2 连接发起多重的请求-响应消息，如多个图片请求；
    1.0 时同一域名有一定的数量限制
  * 应用层(HTTP/2)和传输层(TCP or UDP)之间增加一个二进制分帧层,分割为更小的消息和帧（frame）,并对它们采用二进制格式的编码,突破 HTTP1.1 的性能限制，改进传输性能，实现低延迟和高吞吐量
  * 首部压缩（Header Compression）
  * 服务端推送（Server Push）:同源多页面可以缓存

* `HTTPS`中的`TLS/SSL`是如何保护数据的...

  一般有两种形式,非对称加密,生成公钥和私钥,私钥丢服务器,公钥每次请求去比对验证;

* **call apply bind 区别**

  call 需要把参数按顺序传递进去（需要知道参数数量），而 apply 则是把参数放在数组里（不知道参数数量）

  bind()方法会创建一个新函数，称为绑定函数，当调用这个绑定函数时，绑定函数会以创建它时传入 bind()方法的第一个参数作为 this，传入 bind() 方法的第二个以及以后的参数加上绑定函数运行时本身的参数按照顺序作为原函数的参数来调用原函数。

  call 和 apply 都是对函数的直接调用，而 bind 方法返回的仍然是一个函数，因此后面还需要()来进行调用才可以。

* Promise catch 返回一个 promise(undefined,onRejected)

  catch 之后 then 也会执行

* **标记清除**

  这是 javascript 中最常用的垃圾回收方式。当变量进入执行环境是，就标记这个变量为“进入环境”。从逻辑上讲，永远不能释放进入环境的变量所占用的内存，因为只要执行流进入相应的环境，就可能会用到他们。当变量离开环境时，则将其标记为“离开环境”。

  变量设置为 null，则会在下次进行垃圾回收

* new 关键字就意味着一次内存分配。在初始化的时候新建对象，在后续中尽量多重用这些创建好的对象。

  * 第一步：创建一个新对象
  * 第二步：将构造函数的作用域赋给新对象（this）
  * 第三步：执行构造函数中的代码（为新对象添加属性）
  * 第四部：返回新的对象

  另外还有以下三种内存分配表达式（可能不像 new 关键字那么明显了）：

  * {} （创建一个新对象）
  * [] （创建一个新数组）
  * function() {…}

* **异常捕获**

  * `try catch`

  * `promise` 中的`catch` 和`reject`

    ```javascript
    throw Error('永远无法被捕获') //该错误信息无法在catch中捕获
    ```

  * `window.onerror`

    `window.onerror`包含了`try...catch`的优势，而`try...catch`无法捕获的语法错误和全局异常处理，`window.onerror`都可以做到。不过，由于是全局监测，就会统计到浏览器插件中的 js 异常。

  * **js 原生错误类型**

    * SyntaxError 解析代码时发生的语法错误。
    * ReferenceError 引用一个不存在的变量时发生的错误。
    * RangeError 当一个值超出有效范围时发生的错误。
    * TypeError 是变量或参数不是预期类型时发生的错误。

* 浅拷贝：引用复制和 Object.assign

  深拷贝：

  * 利用 Array 的 slice 和 concat 方法

  * Json 的 parse 和 stringify

  * 实现
    ```javascript
    function deepClone(initalObj, finalObj) {
      var obj = finalObj || {}
      for (var i in initalObj) { // 遍历原有对象属性
        var prop = initalObj[i] // 避免相互引用对象导致死循环，如initalObj.a = initalObj的情况
        if (prop === obj) {
          continue
        }
        if (typeof prop === 'object') {
          obj[i] = prop.constructor === Array ? [] : Object.create(prop)
        } else {
          obj[i] = prop
        }
      }
      return obj
    }
    ```

* resize 和 scroll 事件的性能优化

  resize: debounce

  ```javascript
  var debounce = function(idle, action) {
    var last
    return function() {
      var ctx = this,
        args = arguments
      clearTimeout(last) // 将上一次的定时事件取消
      last = setTimeout(function() {
        action.apply(ctx, args)
      }, idle)
    }
  }
  ```

  ​
  scroll：throttle

  ```javascript
  var throttle = function(delay, action) {
    var last = 0
    return function() {
      var curr = +new Date() // performance.now()更好
      if (curr - last > delay) {
        action.apply(this, arguments)
        last = curr
      }
    }
  }
  ```

  ​

* Object.create()的 polyfill

  ```javascript
  function pureObject(obj) {
    //定义了一个临时构造函数
    function F() {}
    //将这个临时构造函数的原型指向了传入进来的对象。
    F.prototype = obj
    //返回这个构造函数的一个实例。该实例拥有obj的所有属性和方法。
    //因为该实例的原型是obj对象。
    return new F()
  }
  ```


* [ ] [牛客网](https://www.nowcoder.com/ta/front-end-interview?query=&asc=true&order=&page=3)

- [ ] 项目

* [ ] webpack

  * 多入口文件

    `CommonsChunkPlugin`

  * 打包优化

    1.  `resolve.alias` 重定向到压缩后代码而非引入源码
    2.  `module.noParse` 确定一个模块中没有其它新的依赖使用
    3.  `externals.xxx.true` 使用公用 CDN

  * 动态加载

    ​ `require.ensure(dependencies, callback, chunkName) `

* [x] React

  * 好处

    1. 专注于视图层的解决，数据决定视图，函数式思想
    2.  用virtual dom，避免直接进行dom操作，使代码容易维护
    3.  组件化开发的思路，使组件可复用、可组合、可测试、可维护
    4.  生态环境好
    5.  vitural dom可以跨平台输出，方便跨平台集成
    6. 提倡Immutable，避免过度重新渲染
    7. 单向数据流，更容易对数据进行控制，找到数据源头

  * 受控组件与非受控组件

    受控组件的表单数据由React组件处理

    非受控组件的表单由DOM处理，需要用ref来获取表单值（如`<input type="file">`必须用File Api与文件交互）

  * 生命周期

    当树被卸载，旧的 DOM 节点将被销毁。组件实例会调用 `componentWillUnmount()`。当构建一棵新树，新的 DOM 节点被插入到 DOM 中。组件实例将依次调用 `componentWillMount()`和 `componentDidMount()`。任何与旧树有关的状态都将丢弃。

    当组件更新时，实例仍保持一致，以让状态能够在渲染之间保留。React 通过更新底层组件实例的 props 来产生新元素，并在底层实例上依次调用 `componentWillReceiveProps()` 和 `componentWillUpdate()` 方法。

    `componentWillReceiveProps`当父组件变化时，子组件会调用

  * `Diff 算法`

    见 https://reactjs.org/docs/reconciliation.html

    **三个策略**

    1.  经验：Web UI 中 DOM 节点跨层级的移动特点少；

        对 VDOM 的树比较时，只进行分层比较，同一层次的节点比较

    2.  经验：相同类的组件会生成相似的树形结构，不同的会生成不同的

        * 同一类型的组件，保持相同的底层 DOM 节点，并仅更新变化的属性。
        * 不是同一类，替换所有子节点
        * 可以用 shouldComponentUpdate（）来判断否需要 diff

    3.  同一层的一组子节点，可以用唯一的 id 区分相同子节点加上 key 作为标识

  * React 事件

    在 React 中不会把所有的事件处理器绑定到相应的真实的 DOM 节点上，而是使用一个统一的事件监听器，把所有的事件绑定在最外层。当事件发生的时候，首先被这个统一的事件监听器处理，随后找到真正的事件处理函数进行调用，这样是为了提高效率，这是因为在 UI 系统中，事件处理器越多，那么占据的内存就越大，React 的做法是将其简化为一个，这样就大大提高了效率。在之前开发者需要为了优化性能需要自己来优化自己的事件处理器的代码，现在 React 帮助你完成了这些工作。

  * 性能优化

    * 纯函数

    * PureRender（PureComponent，如果之前props与当前props浅比较相同时，不会render）

      用Immutable.is更简单（利用两个对象的hashcode和valueof）

    * 动态子组件设置key

  * Immutable

    节省内存，结构共享，不同对象的相同引用对象，相等

    不可变，降低复杂度和不可预测性

    函数式编程，链式api

* [x] **React-Router**

  基于 history 库，实现了 URL 与 UI 的同步

  http://zhenhua-lee.github.io/react/history.html

  state存储在sessionStorage中

  ![img](http://zhenhua-lee.github.io/img/react-router/internal.png)

![img](http://zhenhua-lee.github.io/img/react-router/upper.png)

![img](http://zhenhua-lee.github.io/img/react-router/base.png)

* [x] Flux

  `dispatcher` 分发 view 传入的数据

  `store` 存储数据，根据 action 的 type 来修改数据（与 Redux 不同，会存在多个 store）

  `view` 视图组件如 React，修改数据时要 dispatcher 一个 action

  `controller view` store 与 view 层进行绑定的定义与方式

* [x] Redux

  Redux 的三大原则

  * 数据 store 唯一
  * 状态都是只读的
  * 纯函数实现 state 改变

  Redux 设计模型：单例模式（store），中介者模式，装饰者模式，订阅者模式

  _`redux-thunk`_ 的主要思想是扩展 action，使得 action 从一个对象变成一个函数，getState和dispatch来进行读写

  _`redux-thunk`_ 的缺点：

  （1）action 虽然扩展了，但因此变得复杂，后期可维护性降低；

  （2）thunks 内部测试逻辑比较困难，需要 mock 所有的触发函数；

  （3）协调并发任务比较困难，当自己的 action 调用了别人的 action，别人的 action 发生改动，则需要自己主动修改；

  （4）业务逻辑会散布在不同的地方：启动的模块，组件以及 thunks 内部。

  `redux-saga` 采用 Generator 函数来 yield Effects（包含指令的文本对象）

  在 _redux-saga_ 中，UI 组件自身从来不会触发任务，它们总是会 `dispatch` 一个 action 来通知在 UI 中哪些地方发生了改变，而不需要对 action 进行修改。

  **worker saga**
  做所有的工作，如调用 API，进行异步请求，并且获得返回结果

  **watcher saga**
  监听被 dispatch 的 actions，当接收到 action 或者知道其被触发时，调用 worker saga 执行任务

  **root saga**
  立即启动 sagas 的唯一入口

* [x] Vue

  * Vue 原理

    采用数据劫持结合发布者-订阅者模式的方式，利用 dependence 来收集数据变化，用`Object.defineProperty` 对数据的 setter 与 getter 方法进行修改进行响应

  * https://github.com/DMQ/mvvm

    * 数据监听器 Observer，能够对数据对象的所有属性进行监听，如有变动可拿到最新值并通知订阅者
    * 指令解析器 Compile，对每个元素节点的指令进行扫描和解析，根据指令模板替换数据，以及绑定相应的更新函数
    * Watcher，作为连接 Observer 和 Compile 的桥梁，能够订阅并收到每个属性变动的通知，执行指令绑定的相应回调函数，从而更新视图

    ![img](https://github.com/DMQ/mvvm/raw/master/img/2.png)

  * TypeScript

    ```javascript
    // tsconfig.json
    {
      "compilerOptions": {
        // 与 Vue 的浏览器支持保持一致
        "target": "es5",
        // 这可以对 `this` 上的数据属性进行更严格的推断
        "strict": true,
        // 如果使用 webpack 2+ 或 rollup，可以利用 tree-shake:
        "module": "es2015",
        "moduleResolution": "node"
      }
    }
    ```

  * 标注返回值

    因为 Vue 的声明文件天生就具有循环性，TypeScript 可能在推断某个方法的类型的时候存在困难。因此，你可能需要在 render 或 computed 里的方法上标注返回值

- [ ] RxJs

- [x] D3

* [x] koa

  洋葱圈模型

  中间件：普通函数与 async 异步函数

  * `ctx.cookies.get(name, [options])` 读取上下文请求中的 cookie
  * `ctx.cookies.set(name, value, [options])` 在上下文中写入 cookie
  * session 没有原生操作，如果 session 数据量很小，可以直接存在内存中 `koa-session-minimal`
  * 如果 session 数据量很大，则需要存储介质存放 session 数据 `koa-mysql-session`

- [ ] node

  用一句话来说明就是，require方能看到的只有module.exports这个对象，它是看不到exports对象的，而我们在编写模块时用到的exports对象实际上只是对module.exports的引用。

  exports是引用 module.exports的值。module.exports 被改变的时候，exports不会被改变，而模块导出的时候，真正导出的执行是module.exports，而不是exports.

  exports是个变量，可以被自定义变量覆盖

- [x] Babel

  `ES6代码输入 ==》 babylon进行解析 ==》 得到AST ==》 plugin用babel-traverse对AST树进行遍历转译 ==》 得到新的AST树 ==》 用babel-generator通过AST树生成ES5代码 `

  `babel-preset-env` 允许你指定一个代码执行环境，并且只编译该环境缺少的特性。

  `babel-polyfill`

  babel 预设可以编译几乎所有的 JavaScript 新语法，但是对于 API 却不能解决，解决这个问题 babel 用的是 babel-polyfill (它有 core-js 和 regenerator 两部分构成)。

  `babel-plugin-tranform-classes`// 解决 ES6 类（class）的兼容性

- [x] code split

  * webpack
    * 入口起点：使用 entry 配置手动地分离代码。
    * 防止重复：使用 CommonsChunkPlugin 去重和分离 chunk。
    * 动态导入：通过模块的内联函数调用来分离代码。
  * React-Router -- 访问到路由才加载加了
    * `getChildRoutes`
    * `getIndexRoute`
    * `getComponents`

- [x] 静态资源的更新

  1.  如果先覆盖 index.html，后覆盖 a.js，用户在这个时间间隙访问，会得到新的 index.html 配合旧的 a.js 的情况，从而出现错误的页面。
  2.  如果先覆盖 a.js，后覆盖 index.html，用户在这个间隙访问，会得到旧的 index.html 配合新的 a.js 的情况，从而也出现了错误的页面。

  使用基于文件内容的 hash 版本冗余机制

- [x] 性能

      | 优化方向 | 优化手段 |
      | 请求数量 | 合并脚本和样式表，CSS Sprites，拆分初始化负载，划分主域 |
      | 请求带宽 | 开启 GZip，精简 JavaScript，移除重复脚本，图像优化 |
      | 缓存利用 | 使用 CDN，使用外部 JavaScript 和 CSS，添加 Expires 头，减少 DNS 查找，配置 ETag，使 AjaX 可缓存 |
      | 页面结构 | 将样式表放在顶部，将脚本放在底部，尽早刷新文档的输出 |
      | 代码校验 | 避免 CSS 表达式，避免重定向 |

#### 错误代码表

**1XX: 一般用来判断协议更换或者确认服务端收到请求这些**

* 100: 服务端收到部分请求,若是没有拒绝的情况下可以继续传递后续内容
* 101: 客户端请求变换协议,服务端收到确认

**2xx 请求成功,是否创建链接,请求是否接受,是否有内容这些**

**200** 正常；请求已完成。

**201** 正常；紧接 POST 命令。

202 正常；已接受用于处理，但处理尚未完成。

203 正常；部分信息 — 返回的信息只是一部分。

**204** 正常；无响应 — 已接收请求，但不存在要回送的信息。

**3xx 一般用来判断重定向和缓存**

**301** 已移动 — 请求的数据具有新的位置且更改是永久的。(永久重定向)
**302** 已找到 — 请求的数据临时具有不同 URI。（临时重定向）

301表示旧地址A的资源已经被永久地移除了（这个资源不可访问了），**搜索引擎在抓取新内容的同时也将旧的网址交换为重定向之后的网址**；302表示旧地址A的资源还在（仍然可以访问），这个重定向只是临时地从旧地址A跳转到地址B，**搜索引擎会抓取新的内容而保存旧的网址。**（会被劫持）

303 请参阅其它 — 可在另一 URI 下找到对请求的响应，且应使用 GET 方法检索此响应。
**304** 未修改 — 未按预期修改文档。
305 使用代理 — 必须通过位置字段中提供的代理来访问请求的资源。
306 未使用 — 不再使用；保留此代码以便将来使用。

**4xx 一般用来确认授权信息,请求是否出错,页面是否丢失**

**400** 错误请求 — 请求中有语法问题，或不能满足请求。
401 未授权 — 未授权客户机访问数据。
402 需要付款 — 表示计费系统已有效。
**403** 禁止 — 即使有授权也不需要访问。
**404** 找不到 — 服务器找不到给定的资源；文档不存在。
407 代理认证请求 — 客户机首先必须使用代理认证自身。
415 介质类型不受支持 — 服务器拒绝服务请求，因为不支持请求实体的格式。

#### 5xx 服务器中出现的错误

**500** 内部错误 — 因为意外情况，服务器不能完成请求。
501 未执行 — 服务器不支持请求的工具。
**502** 错误网关 — 服务器接收到来自上游服务器的无效响应。
503 无法获得服务 — 由于临时过载或维护，服务器无法处理请求。

**repaint** —— 重绘

当一个 DOM 元素的外观发生改变时（例如：outline, visibility, color, background color 等改变）， 浏览器会根据元素的新样式属性重新绘制，使元素呈现新的外观，这个过程叫做 **重绘**, **它不会影响到布局**。重绘的性能代价是高昂的，因为浏览器必须验证 DOM 树上其他节点元素的可见性。

##### 什么情况只发生 repaint（重绘）

* 仅修改 DOM 元素的 **颜色属性**（color, background-color, border-color …）或 **visibility、outline 属性**，因为不会改变布局 所以只发生 repaint

**reflow** —— 回流

可以理解为渲染树需要重新计算，并根据计算的结果 将元素渲染到它所在屏幕上的确切坐标，回流影响到部分（或整个）页面的布局，一个元素回流会导致它所有的子元素、祖先元素、兄弟元素发生回流。

##### 哪些情况会发生 reflow（回流）

* 使用**JS 增加、删除、或修改 DOM 节点**（包括移除或增加样式表）

* 设置元素的**内联样式** 即 style 属性

* 修改元素 **class** 属性

* 更改字体

* CSS 中修改 **display** 属性

* 网页上内容发生变化，例如在 **input** 或 **textarea** 里输入文字

* 计算 offsetWidth 和 offsetHeight 属性

* 缩放（Resize）或滚动浏览器窗口（移动端不存在缩放浏览器窗口的情况）

* 另外，在 webkit 中，当元素应用了 position 为 fixed 或 absolute 时，修改它们的其他 CSS 样式 也只会发生回流（webkit 会作为 layout 操作，其他浏览器只发生重绘）



#### 一些有关减少或避免 reflow（回流）的建议

##### **操作元素样式的技巧：**

* 避免同时设置多个元素的内联样式（style 属性）
* 实现动画时，最好应用在 position 为 fixed 或 absolute 的元素上
* 避免使用 table 布局
* 不要使用 CSS JavaScript 表达式（例如：color: expression((new Date()).getHours()%2 ? “#0091ea” : “#00b8d4” )

**修改 DOM 的技巧：**

* 如果想用 JS 修改元素的样式，最好通过改变元素的 class 名，并尽可能在 DOM 树最末端的节点上修改（例如可以想办法只修改元素子节点上的 class）

* 不要多次修改 DOM，可以使用 document.createDocumentFragment() 把要改的 DOM 节点缓存起来 在内部修改，再一次性添加进 HTML 中

* 将要修改的 DOM 节点设置 display:none，会有一次 repaint，接着可以多次修改，修改完后再设置为 display:block

​

##### 1.常见的网站漏洞有哪些？

有跨站脚本攻击（XSS）、跨站请求伪造（CSRF）、点击劫持、SQL 注入、DDOS 攻击、DNS 劫持

##### 2.简要介绍一下 XSS 以及 XSS 如何防御

跨站脚本攻击是说攻击者通过注入恶意的脚本，在用户浏览网页的时候进行攻击，比如获取 cookie 或者其他用户身份信息。 可以分为存储型和反射型，**存储型是攻击者输入一些数据并且存储到了数据库中，其他浏览者看到的时候进行攻击**，反射型的话 **不存储在数据库中，往往表现为将攻击代码放在 URL 地址的请求参数中**。防御的话为 **cookie 设置 HttpOnly 属性、对用户的输入进行 检查，进行特殊字符串的过滤**

##### 3.简要介绍一下 CSRF(跨站请求伪造)以及如何防御

CSRF 可以理解为**攻击者盗用了用户的身份，以用户的名义发送了恶意请求**。比如这个制造攻击的网站使用一张图片，而这张图片的链接却是可以修改银行转账或账单支付的， 这时候攻击者就以用户的名义进行了对应操作。防御方式的话：**使用验证码、检查 HTTP 头部 referer(告诉服务器我是从哪个页面链接过来的)、使用 token**。

##### 4.网络劫持

代理服务器或 wifi 等中间件的网络请求，进行劫持

https 加密

### 常见的网页性能优化方法

* 减少 HTTP 请求

使用雪碧图、内联图片，合并脚本和样式表。

* 使用内容分发网络（CDN）
* 添加 Expires 头
* 压缩组件

压缩样式表和脚本，开启 gzip 压缩大概减少 70%的大小

* 样式表放在顶部
* 将脚本放在底部
* 避免 CSS 表达式
* 使用外部 JavaScript 和 CSS
* 减少 DNS 查找
* 精简 JavaScript
* 避免重定向

### 进程和线程的区别？

一个程序至少有一个进程，一个进程至少有一个线程，资源分配给进程，同一个进程下的所有线程共享该进程的所有资源。

### SSL 加密

它采用了 RC4、MD5 以及 RSA 等加密算法，使用 40 位的[密钥](https://baike.baidu.com/item/%E5%AF%86%E9%92%A5)，适用于商业信息的加密。

#### GET 与 POST 区别

GET 后退按钮/刷新无害，POST 数据会被重新提交（浏览器应该告知用户数据会被重新提交）。
GET 书签可收藏，POST 为书签不可收藏。
GET 能被缓存，POST 不能缓存 。
GET 编码类型 application/x-www-form-url，POST 编码类型 encodedapplication/x-www-form-urlencoded 或 multipart/form-data。为二进制数据使用多重编码。
GET 历史参数保留在浏览器历史中。POST 参数不会保存在浏览器历史中。
GET 对数据长度有限制，当发送数据时，GET 方法向 URL 添加数据；URL 的长度是受限制的（URL 的最大长度是 2048 个字符）。POST 无限制。
GET 只允许 ASCII 字符。POST 没有限制。也允许二进制数据。与 POST 相比，GET 的安全性较差，因为所发送的数据是 URL 的一部分。在发送密码或其他敏感信息时绝不要使用 GET ！POST 比 GET 更安全，因为参数不会被保存在浏览器历史或 web 服务器日志中。
GET 的数据在 URL 中对所有人都是可见的。POST 的数据不会显示在 URL 中。

**GET 产生一个 TCP 数据包；POST 产生两个 TCP 数据包。**

### CommonJS

NodeJS 就采用了 CommonJS。是这样加载模块：

```JavaScript
var clock = require('clock');
clock.start();
```

这种写法适合服务端，因为在服务器读取模块都是在本地磁盘，加载速度很快

### AMD

AMD，即 (Asynchronous Module Definition)，这种规范是异步的加载模块，requireJs 应用了这一规范。先定义所有依赖，然后在加载完成后的回调函数中执行，开始就把所有依赖写出来是不符合书写的逻辑顺序的。

```
 1.我们在使用requireJS时，都会把所有的js交给requireJS来管理，也就是我们的页面上只引入一个require.js，把data-main指向我们的main.js。

 2.通过我们在main.js里面定义的require方法或者define方法，requireJS会把这些依赖和回调方法都用一个数据结构保存起来。

 3.当页面加载时，requireJS会根据这些依赖预先把需要的js通过document.createElement的方法引入到dom中，这样，被引入dom中的script便会运行。

 4.由于我们依赖的js也是要按照requireJS的规范来写的，所以他们也会有define或者require方法，同样类似第二步这样循环向上查找依赖，同样会把他们村起来。

 5.当我们的js里需要用到依赖所返回的结果时(通常是一个key value类型的object),requireJS便会把之前那个保存回调方法的数据结构里面的方法拿出来并且运行，然后把结果给需要依赖的方法。

 6.以上就是一个简单的流程。
```

### CMD

CMD (Common Module Definition), 是 seajs 推崇的规范，CMD 则是依赖就近，用的时候再 require。

AMD 和 CMD 最大的区别是对依赖模块的执行时机处理不同，而不是加载的时机或者方式不同，二者皆为异步加载模块。AMD 依赖前置，js 可以方便知道依赖模块是谁，立即加载；而 CMD 就近依赖，需要使用把模块变为字符串解析一遍才知道依赖了那些模块。

### es6

CommonJS 模块输出的是一个值的拷贝，ES6 模块输出的是值的引用（会改变引入的值）。

CommonJS 模块是运行时加载，ES6 模块是编译时输出接口。

#### UMD

兼容了 AMD 和 CommonJS，同时还支持老式的“全局”变量规范

### 什么是事件循环（EVENT LOOP）？

js 是单线程的，是指 js 执行引擎是单线程的，除了这个单线程，还有一个 任务队列，在执行 js 代码的过程中，执行引擎遇到注册的延时方法，如定时器，DOM 事件， 会将这些方法交给相应的浏览器模块处理，当这些延时方法有触发条件去触发的时候， 这些延时方法会被添加至任务队列，而这些任务队列中的方法只有 js 的主线程空闲了才会执行， 这也就是说我们常常用的定时器定的时间参数只是一个触发条件，具体多少时间后执行其实还需要看 js 主线程空闲与否

一个事件循环(event loop)会有一个或多个任务队列(task queue) task queue 就是 macrotask queue

每一个 event loop 都有一个 microtask queue

microtask queue> macrotask queue

一个任务 task 可以放入 macrotask queue 也可以放入 microtask queue 中

当一个 task 被放入队列 queue(macro 或 micro) 那这个 task 就可以被立即执行了

task

Marco-task：定时器， I/O，UI 渲染

mirco-stack:promise 和 mutation observer

### 原生 JS 操作 DOM 的方法有哪些？

获取节点的方法

getElementById、getElementsByClassName、getElementsByTagName、 getElementsByName、querySelector、querySelectorAll

对元素属性进行操作

getAttribute、 setAttribute、removeAttribute 方法

对节点进行增删改

appendChild、insertBefore、replaceChild、removeChild、 createElement 等

### JavaScript 严格模式下有哪些不同？

* 不允许不使用 var 关键字去创建全局变量，抛出 ReferenceError
* 不允许对变量使用 delete 操作符，抛 ReferenceError
* 不可对对象的只读属性赋值，不可对对象的不可配置属性使用 delete 操作符，不可为不可拓展的对象添加属性，均抛 TypeError
* 对象属性名必须唯一
* 函数中不可有重名参数
* 在函数内部对修改参数不会反映到 arguments 中
* 淘汰 arguments.callee 和 arguments.caller
* 不可在 if 内部声明函数
* 抛弃 with 语句

##### addEventListener 有哪些参数？

有三个参数，第一个是事件的类型，第二个是事件的回调函数，第三个是一个表示事件是冒泡阶段还是捕获阶段捕获的布尔值，true 表示捕获，false 表示冒泡

##### jsonp 的实现思路

创建一个 script 标签，设置 src 为相应的 url，在 url 之后添加相应的 callback，格式类似于 url?callback=xxx

##### 将静态资源放在其他域名的目的是什么？

这样做的主要目的是在请求这些静态资源的时候不会发送 cookie，节省了流量，需要注意的是 cookie 是会发送给子域名的（二级域名），所以这些静态资源是不会放在子域名下的， 而是单独放在一个单独的主域名下。同时还有一个原因就是浏览器对于一个域名会有请求数的限制，这种方法可以方便做 CDN。

##### 前端如何实现 PV 和 UV 的统计

​ PV(访问量)：Page View, 即页面浏览量或点击量，用户每次刷新即被计算一次。

UV(独立访客)：Unique Visitor,一般使用 cookie 标记,访问您网站的一台电脑客户端(比如一台电脑开多个浏览器访问则为多个 UV)为一个访客，00:00-24:00 内相同的客户端只会被计算一次。

IP(独立 IP)：指独立 IP 数。00:00-24:00 内相同 IP 地址之被计算一次(多台电脑可能共用一个 ip)。

##### 实现深拷贝函数

对于非引用值类型的数值，直接赋值，而对于引用值类型（object）还需要再次遍历，递归赋值。

##### ajax 的 readyState 有哪几个状态，含义分别是什么？

ajax 的 readyState 共有 5 个状态，分别是 0-4，0 代表还没调用 open 方法，1 代表的是未调用 send 方法，也就是还没发送数据给服务器，2 代表的是还没有接收到响应，3 代表的是开始接收到了部分数据，4 代表的是接收完成

#### ES7 特性：

1.`Array.prototype.includes`
2.Exponentiation Operator(求冥运算) —— 2**3=8

#### ES8 特性：

##### 字符串填充

* 此部分将两个函数添加到 String 对象：padStart＆padEnd。

* `Object.values 和 Object.entries`

* `Object.getOwnPropertyDescriptors`

* `async` `await`

* 共享内存和原子

##### SPA 的路由

1.  修改 url 中 Hash
2.  利用 H5 中的 history

##### Service Worker

* 它是一种 JavaScript 工作线程，无法直接访问 DOM。 服务工作线程通过响应 postMessage 接口发送的消息来与其控制的页面通信，页面可在必要时对 DOM 执行操作。
* 服务工作线程是一种可编程网络代理，让您能够控制页面所发送网络请求的处理方式。
* 它在不用时会被中止，并在下次有需要时重启，因此，您不能依赖于服务工作线程的 onfetch 和 onmessage 处理程序中的全局状态。如果存在您需要持续保存并在重启后加以重用的信息，服务工作线程可以访问 IndexedDB API。
* 服务工作线程广泛地利用了 promise

##### Canvas 优化

* 分层 Canvas
* 离屏渲染
* 避免无用的绘制
* webworker 和拆分任务

##### 职责链模式？

将一个流程进行分解，让这个流程在多个对象中进行传递，由最后一个对象完成这个流程。通过职责链模式能够将流程进行分解，从而解耦。

##### CSS3 的新特性

* 在布局方面新增了 flex 布局
* 在选择器方面新增了例如:first-of-type,nth-child 等选择器
* 在盒模型方面添加了 box-sizing 来改变盒模型
* 在动画方面增加了 animation、2d 变换、3d 变换等
* 在颜色方面添加透明、rgba 等
* 在字体方面 允许嵌入字体和设置字体阴影,
* 盒子的阴影
* 关键的媒体查询。

##### CSS 硬件加速

​ 触发硬件加速的 CSS 属性有 transform、opacity、filter，为了避免 2D 动画在 开始和结束的时候的 repaint 操作，一般使用 tranform:translateZ(0)

##### BFC 是什么？介绍一下，如何触发 BFC？

BFC 也就是常说的块格式化上下文，这是一个独立的渲染区域，规定了内部如何布局，并且这个区域的子元素不会影响到外面的元素。其中比较重要的布局规则有内部 box 垂直放置、计算 BFC 的高度的时候，浮动元素也参与计算。 触发 BFC 的规则有根元素、浮动元素、position 为 absolute 或 fixed 的元素、display 属性为 inline-block、table-cell、table-caption、flex、inline-fllex、overflow 不为 visible 的元素。

##### CSS3 动画如何实现暂停？

css3 动画可以通过设置 animation-play-state 属性为 paused 来设置这个动画暂停。

##### 跨域问题

（1）利用 CORS 跨域

"跨域资源共享"（Cross-origin resource sharing，简称 CORS）。CORS 是是在 XHR2 中拓展的能力，使用方法很简单，在服务端设置：

Header set Access-Control-Allow-Origin \*

这种设置将接受所有域名的跨域请求，也可以指定具体网址，也可以对域名进行限定：

Header set Access-Control-Allow-Origin http://www.test.com

然而，这种方式的局限性在于要求客户端支持，并且服务端进行相关设置。在这两者满足的情况下，通过 CORS 进行跨域不仅支持所有类型的 HTTP 请求，而且开发者可以使用普通的 XMLHttpRequest 发起请求和获得数据，比起 JSONP 有更好的错误处理。

#### 简单请求

* 请求方法是如下之一：
  * GET
  * HEAD
  * POST
* 所有的 Header 都在如下列表中：
  * Cache-Control
  * Content-Language
  * Content-Type
  * Expires
  * Last-Modified
  * Pragma

#### 预检请求

会附带一些关于接下来的请求的信息给服务器，主要有以下几种：

Origin：请求的源域信息
Access-Control-Request-Method：接下来的请求类型，如 POST、GET 等
Access-Control-Request-Headers：接下来的请求中包含的用户显式设置的 Header 列表

```java
// 后台处理
response.setHeader('Access-Control-Allow-Origin', '*')
response.setHeader('Access-Control-Allow-Methods', 'POST')
response.setHeader('Access-Control-Allow-Headers', 'x-requested-with,content-type')
response.addHeader('Access-Control-Allow-Credentials', 'true')
```

（2）利用 JSONP 实现跨越

对于较老的浏览器，它们往往不支持 CORS，因此使用 JSONP 进行跨域也是很常见的一种方式。

我们知道在网页中通过`<script>`元素的 src 指定加载目标脚本时是不受同源策略的影响的，因此可以使用它们从其他服务器请求数据，这种利用`<script>`元素作为 Ajax 传输的技术就称为 JSONP。

JSONP 也存在一些弊端。首先 JSONP 支持 GET 不支持 POST 方法，另外使用`<script>`元素进行 Ajax 请求，这意味着允许 Web 页面可以执行远程服务器发送过来的任何 JavaScript 代码，因此对于不信任的服务器，不应该采用该技术。

（3）利用 window.name 进行跨域

window 对象有个 name 属性，该属性有个特征：即在一个窗口(window)的生命周期内,窗口载入的所有的页面都是共享一个 window.name 的，每个页面对 window.name 都有读写的权限，window.name 是持久存在一个窗口载入过的所有页面中的，并不会因新页面的载入而进行重置，因此可以借助 window.name 在不同源的页面中传递数据。

如 www.a.com/a.html 想要获得 www.b.com/b.html 中的数据,原理如下：

a) 在 b.html 中将数据存储在 window.name 中

b) 在 a.html 中构建一个隐藏（display：none）的 iframe 标签，假设 id 设为 proxy，src 设置为和 a.html 同源即可。

（4) 使用 window.postMessage 进行跨域

这种方式比较简单，在 a 页面中利用 windowObj.postMessage(message, targetOrigin)向目标页面发送信息，而在 b 页面中通过监听 message 事件获取信息。这种方式是在 HTML5 中新增的方法，对于 IE6、IE7 等老版本浏览器无法使用。

##### Restful API

* GET /collection：返回资源对象的列表（数组）
* GET /collection/resource：返回单个资源对象
* POST /collection：返回新生成的资源对象
* PUT /collection/resource：返回完整的资源对象
* PATCH /collection/resource：返回完整的资源对象
* DELETE /collection/resource：返回一个空文档

**何为混合应用 (Hybrid APP) ，与原生 Native 应用相比它的优劣势**

Hybrid APP 是 Native APP 上结合使用了 Web View （Native APP 的模块或称组件，用来加载 Web 资源），采用了 Web 技术的 APP，本质上属于原生应用（APP 外壳）。

优势：

兼容性良好，“一次开发，多处运行”，能够减少原生 APP 开发在多平台带来的问题代码移植性高

开发者社区活跃，能够及时应用最新适合的 Web 技术来解决问题，提高用户体验

APP 更加轻便，内容更新方便，部分更新不用从 APP Store 下载劣势：

性能：相对不如 Native APP 性能良好、体验流畅
Web 技术在 APP 中操作权限有限，需要 APP 同步支持

#### 移动端布局

1.  flex 布局
2.  百分比布局与 media query
3.  Rem 适配 + vw
4.  js 处理获取手机 dpr 参数，然后动态生成 viewpoint，动态计算 height 与 width
5.  获取手机物理像素宽度，分成 10 份，每一份的宽度即是 rem 的尺寸
6.  根据设计稿的尺寸（px）分三种情况进行处理，采用 px + rem 布局

### es5 原型与 class

* es5 的每个对象的`__proto__`属性指向构造函数的 prototype 属性；
* Class 同时具有 prototype 属性和`__proto__`属性
* 子类的`__proto__`继承构造函数，指向父类
* 子类 prototype 属性的`__proto__`继承方法，指向父类的`prototype`属性
* Class 没有变量提升，是严格模式
* class 可以加 static 实现静态方法，静态属性必须按 es5 的办法
* new 的时候用 new.target 判断构造函数，因此必须用 new 来调用

# React 与 Vue

React 和 Vue 有许多相似之处，它们都有：

* 使用 Virtual DOM
* 提供了响应式 (Reactive) 和组件化 (Composable) 的视图组件。
* 将注意力集中保持在核心库，而将其他功能如路由和全局状态管理交给相关的库。

#### 优化

在 React 应用中，当某个组件的状态发生变化时，它会以该组件为根，重新渲染整个组件子树。

如要避免不必要的子组件的重渲染，你需要在所有可能的地方使用 `PureComponent`，或是手动实现 `shouldComponentUpdate` 方法。同时你可能会需要使用不可变的数据结构来使得你的组件更容易被优化。

然而，使用 `PureComponent` 和 `shouldComponentUpdate` 时，需要保证该组件的整个子树的渲染输出都是由该组件的 props 所决定的。如果不符合这个情况，那么此类优化就会导致难以察觉的渲染结果不一致。这使得 React 中的组件优化伴随着相当的心智负担。

在 Vue 应用中，组件的依赖是在渲染过程中自动追踪的，所以系统能精确知晓哪个组件确实需要被重渲染。你可以理解为每一个组件都已经自动获得了 `shouldComponentUpdate`，并且没有上述的子树问题限制

**学习难度**

Vue 可以只用 vue 文件来编写，替换成 min 文件即可；React 推荐写法需要学习 es6 等，并且用 Babel 等转译

Vue 的路由库和状态管理由官方维护

Vue 默认推荐模版；React 使用 Jsx

#### Vue 原理

当你把一个普通的 JavaScript 对象传给 Vue 实例的 `data` 选项，Vue 将遍历此对象所有的属性，并使用 [Object.defineProperty](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty) 把这些属性全部转为 getter/setter。Object.defineProperty 是 ES5 中一个无法 shim 的特性，这也就是为什么 Vue 不支持 IE8 以及更低版本浏览器的原因。

这些 getter/setter 对用户来说是不可见的，但是在内部它们让 Vue 追踪依赖，在属性被访问和修改时通知变化。这里需要注意的问题是浏览器控制台在打印数据对象时 getter/setter 的格式化并不同，所以你可能需要安装 [vue-devtools](https://github.com/vuejs/vue-devtools) 来获取更加友好的检查接口。

每个组件实例都有相应的 **watcher** 实例对象，它会在组件渲染的过程中把属性记录为依赖，之后当依赖项的 `setter` 被调用时，会通知 `watcher` 重新计算，从而致使它关联的组件得以更新。

![data](https://cn.vuejs.org/images/data.png)

Vue **异步**执行 DOM 更新。只要观察到数据变化，Vue 将开启一个队列，并缓冲在同一事件循环中发生的所有数据改变。如果同一个 watcher 被多次触发，只会被推入到队列中一次。这种在缓冲时去除重复数据对于避免不必要的计算和 DOM 操作上非常重要。然后，在下一个的事件循环“tick”中，Vue 刷新队列并执行实际 (已去重的) 工作。Vue 在内部尝试对异步队列使用原生的 `Promise.then` 和 `MessageChannel`，如果执行环境不支持，会采用 `setTimeout(fn, 0)` 代替。

# 浏览器

浏览器内核是多线程，在内核控制下各线程相互配合以保持同步，一个浏览器通常由以下常驻线程组成：

* GUI 渲染线程
* JavaScript 引擎线程
* 定时触发器线程
* 事件触发线程
* 异步 http 请求线程

**GUI 渲染线程 与 JavaScript 引擎线程互斥！**，因此 js 执行时会阻塞浏览器渲染

### Javascript 是单线程的

Javascript 是单线程的, 那么为什么 Javascript 要是单线程的？

这是因为 Javascript 这门脚本语言诞生的使命所致：JavaScript 为处理页面中用户的交互，以及操作 DOM 树、CSS 样式树来给用户呈现一份动态而丰富的交互体验和服务器逻辑的交互处理。如果 JavaScript 是多线程的方式来操作这些 UI DOM，则可能出现 UI 操作的冲突； **如果 Javascript 是多线程的话，在多线程的交互下，处于 UI 中的 DOM 节点就可能成为一个临界资源，假设存在两个线程同时操作一个 DOM，一个负责修改一个负责删除，那么这个时候就需要浏览器来裁决如何生效哪个线程的执行结果。**当然我们可以通过锁来解决上面的问题。但为了避免因为引入了锁而带来更大的复杂性，Javascript 在最初就选择了单线程执行。

### GUI 渲染线程 与 JavaScript 引擎线程互斥！

由于 JavaScript 是可操纵 DOM 的，如果在修改这些元素属性同时渲染界面（即 JavaScript 线程和 UI 线程同时运行），那么渲染线程前后获得的元素数据就可能不一致了。因此为了防止渲染出现不可预期的结果，浏览器设置 GUI 渲染线程与 JavaScript 引擎为互斥的关系，当 JavaScript 引擎执行时 GUI 线程会被挂起，GUI 更新会被保存在一个队列中等到引擎线程空闲时立即被执行。

### JS 阻塞页面加载

从上面我们可以推理出，由于 GUI 渲染线程与 JavaScript 执行线程是互斥的关系，当浏览器在执行 JavaScript 程序的时候，**GUI 渲染线程会被保存在一个队列中，直到 JS 程序执行完成，才会接着执行**。因此如果 JS 执行的时间过长，这样就会造成页面的渲染不连贯，导致页面渲染加载阻塞的感觉。

### 定时触发器线程

浏览器定时计数器并不是由 JavaScript 引擎计数的, 因为 JavaScript 引擎是单线程的, 如果处于阻塞线程状态就会影响记计时的准确, 因此通过单独线程来计时并触发定时是更为合理的方案。

### 事件触发线程

当一个事件被触发时该线程会把事件添加到待处理队列的队尾，等待 JS 引擎的处理。这些事件可以是当前执行的代码块如定时任务、也可来自浏览器内核的其他线程如鼠标点击、AJAX 异步请求等，但由于 JS 的单线程关系所有这些事件都得排队等待 JS 引擎处理。

### 异步 http 请求线程

在 XMLHttpRequest 在连接后是通过浏览器新开一个线程请求， 将检测到状态变更时，如果设置有回调函数，异步线程就产生状态变更事件放到 JavaScript 引擎的处理队列中等待处理。

# web 测试

1.  明确测试目的
2.  并发用户数
3.  最耗资源的功能
4.  最频繁使用功能和访问的页面
5.  网络、设备因素
6.  一些压力测试工具
7.  js 功能测试：Jtest ，snapshot 快照测试
8.  组件：storybook

# React 安全

React 会对字符进行转译替换成字符串，从而保证了安全性

# 一些题目

* ([“1”,”2”,”3”]).map(parseInt)

[1,NaN,NaN]

因为 parseInt 有两个参数，number 和 radix，map 会把数组的 index 作为 radix 传入，当 number 大于 radix 会成为 NaN

* 同时发送几个请求，但是需要等到所有请求结束再执行回调？

promise.all()

* mainfiest（deprecated）

首先 manifest 是一个后缀名为 minifest 的文件，在文件中定义那些需要缓存的文件，支持 manifest 的浏览器，会将按照 manifest 文件的规则，像文件保存在本地，从而在没有网络链接的情况下，也能访问页面。

当我们第一次正确配置 app cache 后，当我们再次访问该应用时，浏览器会首先检查 manifest 文件是否有变动，如果有变动就会把相应的变得跟新下来，同时改变浏览器里面的 app cache，如果没有变动，就会直接把 app cache 的资源返回，基本流程是这样的。

* 离线浏览: 用户可以在离线状态下浏览网站内容。
* 更快的速度: 因为数据被存储在本地，所以速度会更快.
* 减轻服务器的负载: 浏览器只会下载在服务器上发生改变的资源。

**如何更新缓存**

更新 manifest 文件  / 通过 javascript 操作 / 清除浏览器缓存

**优点**

+ 可以离线运行
+ 可以减少资源请求
+ 可以更新资源

**缺点**

+ 更新的资源，需要二次刷新才会被页面采用
+ 不支持增量更新，只有manifest发生变化，所有资源全部重新下载一次，资源变化时不会更新
+ 缺乏足够容错机制，当清单中任意资源文件出现加载异常，都会导致整个manifest策略运行异常

给 manifest 添加或删除文件，都可更新缓存，如果我们更改了 js，而没有新增或删除，前面例子中注释中的版本号，可以很好的用来更新 manifest 文件。

html5 中引入了 js 操作离线缓存的方法，下面的 js 可以手动更新本地缓存。

```
window.applicationCache.update();
```

如果用户清除了浏览器缓存（手动或用其他一些工具）都会重新下载文件。



![img](https://images0.cnblogs.com/blog/512692/201304/12095757-775cf861406644bfad60ff2763f499e4.png)



**禁止js操作Cookie**

服务端设置了http-only属性的Cookie，客户端JS无法读取，更别说更改了。

跨域的Cookie会存取失败（跨二级域名不包括在内）。

如果浏览器设置了**阻止网站设置任何数据**， 客户端无法接收Cookie，当然JS对Cookie的操作会失败。

Cookie的数量超过最大限制，之前的Cookie被自动删除，JS无法读取到。

Cookie过期被浏览器自动删除了。



| 进程占有的资源                                           | 线程占有的资源               |
| -------------------------------------------------------- | ---------------------------- |
| 地址空间  全局变量  打开的文件  子进程  信号量  账户信息 | 栈  寄存器  状态  程序计数器 |

![img](http://hi.csdn.net/attachment/201108/7/0_131271823564Rx.gif)

## 文件名加上hash值的原因

另外会设置特别长的max-age和过期时间

文件没有变动**的时候，浏览器不用发起请求直接可以使用缓存文件；而在**文件有变化**的时候，由于文件版本号的变更，导致文件名变化，请求的url变了，自然文件就更新了。这样能确保客户端能及时从服务器收取到新修改的文件。通过这样的处理，增长了静态资源，特别是图片资源的缓存时间，避免该资源很快过期，客户端频繁向服务端发起资源请求，服务器再返回304响应的情况（有Last-Modified/Etag）

## 大公司部署

配置超长时间的本地缓存                 —— 节省带宽，提高性能

采用内容摘要作为缓存更新依据      —— 精确的缓存控制

静态资源CDN部署                           —— 优化网络请求

更资源发布路径实现非覆盖式发布  —— 平滑升级



## js模块加载原理

**原理一：*id即路径* 原则。**
通常我们的入口是这样的： require( [ 'a', 'b' ], callback ) 。这里的 'a'、'b' 都是 ModuleId。通过 id 和路径的对应原则，加载器才能知道需要加载的 js 的路径。在这个例子里，就是 baseUrl + 'a.js' 和 baseUrl + 'b.js'。

但 id 和 path 的对应关系并不是永远那么简单，比如在 AMD 规范里就可以通过配置 Paths  来给特定的 id 指配 path。

**原理二：createElement('script') & appendChild**
知道路径之后，就需要去请求。一般是通过 **createElement('script') & appendChild** 去请求。这个大家都知道，不多说。有时候有的加载器也会通过 AJAX 去请求脚本内容。

一般来说，需要给 <script> 设置一个属性用来标识模块 id, 作用后面会提到。

**原理三：document.currentScript**
a.js 里可能是 define( id, factory ) 或者是 define( factory )，后者被称为匿名模块。那么当 define(factory) 被执行的时候，我们怎么知道当前被定义的是哪个模块呢，具体地说，这个匿名模块的实际模块 id 是什么？ 答案是通过 **document.currentScript** 获取当前执行的<script>，然后通过上面给 script 设置的属性来得到模块 id。

需要注意的是，低级浏览器是不支持 currentScript 的，这里需要进行浏览器兼容。**在高级浏览器里面，还可以通过 script.onload 来处理这个事情。**

**原理四：依赖分析**
在继续讲之前，需要先简单介绍下模块的生命周期。模块在被 Define 之后并不是马上可以用了，在你执行它的 factory 方法来生产出最终的 export 之前，你需要保证它的依赖是可用的。那么首先就要先把依赖分析出来。

简单来说，就是通过 toString 这个方法得到 factory 的内容，然后用正则去匹配其中的 require( 'moduleId' )。当然也可以不用正则。

这就是为什么 require( var );  这种带变量的语句是不被推荐的，因为它会影响依赖分析。如果一定要用变量，可以用 require( [ var ] ) 这种异步加载的方式。

**原理五：递归加载**
在分析出模块的依赖之后，我们需要递归去加载依赖模块



## Webpack原理

1. 执行脚本 ./bin/webpack.js

2. 使用相关模块获取到配置对象，然后从./lib/webpack.js 中获取到webpack来进行编译

3. 调用 lib/WebpackOptionsApply.js 模块的 process 方法来逐一编译 webpack 编译对象的各项

4. 整个个bundle.js是一个自执行函数，前65行都在定义这个自执行函数，最后传入了一个数组作为参数，因为只有一个js文件，这里的数组长度为1，并且数组里的每一个元素都是一个自执行函数，自执行函数中包含着index.js里的内容。 

   即整个bundle.js文件是一个传入了 包含若干个模块的数组 作为参数，即**传入的modules是一个数组**。 

5. 在这个bundle.js文件中的自执行函数中定义了一个webpack打包的函数 **__webpack_require__**, 这个函数式一个打包的核心函数， 接收一个moduleId作为参数，**moduleId是一个数字，实际上就是整个自执行函数接收的数组参数的index值。** 即整个传入的module数组，每一个元素都是一个module，我们为之定义一个特定的moduleId，**进入函数，首先判断要加载的模块是否已经存在，如果已经存在， 就直接返回installedModules[moduleId].exports，这样就保证了所有的模块只会被加载一次，而不会被多次加载。 如果说这个模块还没有被加载，那么我们就创建一个installedModules[moduleId]， 他是一个对象，包括i属性（即moduleId），l属性（表示这个模块是否已经被加载， 初始化为false）, exports 属性它的内容是每个模块想要导出的内容， 接下来执行  modules[moduleId].call(module.exports, module, module.exports, __webpack_require__); 函数进行调用，那么这个函数具体是如何执行的呢？ 首先保证在module.exports上进行调用这个函数，然后传入了module参数，即我们想要调用的这个模块，传入module.exports ，那么在每一个模块中使用的module和module.exports就都是属于这个模块的了， 同时再传入 __webpack_require__这样我们就可以在每一个模块中继续使用了加载器了，最后，导出这个模块。 调用完成之后，将l设置为true，表示已经加载，最后导出module.exports,即导出加载到的模块。**

6. 在自执行函数的末尾我们可以看到这个**自执行函数最终返回了一个 __webpack_require__ 调用**，也就是说返回了一个模块，因为__webpck_require__函数本身就会返回一个模块。 并且这个 __webpack_require__调用接收的参数是一个 moduleId ，且指明了其值为86。 **也就是说入口文件的 moduleId 为86，** 我们来看一看模块 86 的内容是什么。**即在这个bundle.js函数执行之后，实际上得到的第一部分内容是 86 模块的内容**

7. `style-loader`  :**将css代码添加到html中，这个模块中的的核心函数为 addStylesToDom**,内部对所有的style进行遍历， 然后添加进入

webpack的loader从右往左，从下往上执行