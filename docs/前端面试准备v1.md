# 前端面试准备

### PWA

- serviceworker：实现通知功能
- cacheStorage || indexedDB：实现页面缓存和骨架屏
- mainfiest.json： 实现桌面图标

### HTML

- sessionStorage，localStroage 可以跨页面，但不能跨域（必须来自同一域名，同一种协议，同一个端口）

  sessionStorage 只保持在到浏览器关闭

- CDN 网络是在用户和服务器之间增加 Cache 层，如何将用户的请求引导到 Cache 上获得源服务器的数据，主要是通过接管 DNS 实现。

  浏览器调用域名解析库对域名进行解析，由于 CDN 对域名解析过程进行了调整，所以解析函数库得到的是该域名对应的 CNAME 记录（由于现在已经是使用了 CDN 服务，CNAME 为 CDN 服务商域名），为了得到实际 IP 地址，浏览器需要再次对获得的 CNAME 域名进行解析以得到实际的 IP 地址；在此过程中，使用的全局负载均衡 DNS 解析，如根据地理位置信息解析对应的 IP 地址，使得用户能就近访问。（CDN 服务来提供最近的机器）

- `<script>`标签打开`defer`或`async`属性，脚本就会异步加载。渲染引擎遇到这一行命令，就会开始下载外部脚本，但不会等它下载和执行，而是直接执行后面的命令。

  `defer`与`async`的区别是：`defer`要等到整个页面在内存中正常渲染结束（DOM 结构完全生成，以及其他脚本执行完成），才会执行；`async`一旦下载完，渲染引擎就会中断渲染，执行这个脚本以后，再继续渲染。一句话，`defer`是“渲染完再执行”，`async`是“下载完就执行”。另外，如果有多个`defer`脚本，会按照它们在页面出现的顺序加载，而多个`async`脚本是不能保证加载顺序的。

- 缓存：(expires 和 cache-control 返回 200，last-modified/Etag 返回 304)

  - `Cache-Control` ：

    - `max-age` 秒为单位，会覆盖 Expires
    - `Public` 指示响应可被**任何缓存区**缓存。
    - `Private` 指示对于单个用户的整个或部分响应消息，不能被共享缓存处理。这允许服务器仅仅描述当用户的部分响应消息，此响应消息对于其他用户的请求无效
    - `no-cache` 指示请求或响应消息不能缓存（HTTP/1.0 用 Pragma 的 no-cache 替换）
    - `no-store` 表示必须先与服务器确认返回的响应是否发生了变化，然后才能使用该响应来满足后续对同一网址的请求。
    - `no-store` 不允许缓存响应，每次请求都必须完整获取。

  - `Expires`：指明过期的时间

  - `Last-Modified`：最后修改的时间

    客户端第二次请求此 URL 时，根据 HTTP 协议的规定，浏览器会向服务器传送**If-Modified-Since**报头(HttpRequest Header)，询问该时间之后文件是否有被修改过

  - `etag`：根据文件内容 hash

    - 在客户端发出请求后，HttpReponse Header 中包含 Etag:“5d8c72a5edda8d6a:3239″标识，等于告诉 Client 端，你拿到的这个的资源有表示 ID：5d8c72a5edda8d6a:3239。当下次需要发 Request 索要同一个 URI 的时候，浏览器同时发出一个**If-None-Match**报头(Http RequestHeader)此时包头中信息包含上次访问得到的 Etag:“5d8c72a5edda8d6a:3239″标识。

    - 分布式系统里多台机器间文件的 last-modified 必须保持一致，以免负载均衡到不同机器导致比对失败分布式系统尽量关闭掉 Etag(每台机器生成的 etag 都会不一样)

    If-None-Match 为 False，不返回 200，返回 304(Not Modified) Response。

  1. 判断`expires`，如果未过期，直接读取 http 缓存文件，不发 http 请求，否则进入下一步

  2. 判断是否含有`etag`，有则带上 `if-none-match` 发送请求，未修改返回 `304 not modified`，修改返回`200` ，否则进入下一步

  3. 判断是否含有 last-modified，有则带上 if-modified-since 发送请求，无效返回 200，有效返回 304，否则直接向服务器请求

     ![img](http://7tszky.com1.z0.glb.clouddn.com/FgtfwfAjs5EBAEIa9KFi25acNk7d)

### 跨域

1. 主域相同可以设置 document.domain

   使用 document.domain 来允许子域安全访问其父域时，您需要在父域和子域中设置 document.domain 为相同的值

2. script 可以跨域执行；动态创建 script，设置 js 的 callback，返回函数与参数（放置数据）

3. iframe 和 location.hash

4. window.name 实现的跨域数据传输


    name 值在不同的页面（甚至不同域名）加载后依旧存在，并且可以支持非常长的 name 值（2MB）

5. 使用 HTML5 postMessage


    `otherWindow` : 对接收信息页面的 window 的引用。可以是页面中 iframe 的 contentWindow 属性；window.open 的返回值；通过 name 或下标从 window.frames 取到的值。

    `message` : 所要发送的数据，string 类型。

    `targetOrigin` : 用于限制 otherWindow，“\*”表示不作限制

6. cors
   cors 的话,可控性较强,需要前后端都设置,兼容性 IE10+ ,比如


    Access-Control-Allow-Origin: http://foo.example // 子域乃至整个域名或所有域名是否允许访问

    Access-Control-Allow-Methods: POST, GET, OPTIONS // 允许那些行为方法

    Access-Control-Allow-Headers: X-PINGOTHER, Content-Type // 允许的头部字段

    Access-Control-Max-Age: 86400 // 有效期

7. HTTP 请求


    HTTP/1.1 协议中共定义了 8 种 HTTP 请求方法，HTTP 请求方法也被叫做“请求动作”，不同的方法规定了不同的操作指定的资源方式。服务端也会根据不同的请求方法做不同的响应。

    **幂等：多次操作返回的结果相同**

    **GET**

    GET 请求会显示请求指定的资源。一般来说 GET 方法应该只用于数据的读取，而不应当用于会产生副作用的非幂等的操作中。
    GET 会方法请求指定的页面信息，并返回响应主体，GET 被认为是不安全的方法，因为 GET 方法会被网络蜘蛛等任意的访问。

    **HEAD**

    HEAD 方法与 GET 方法一样，都是向服务器发出指定资源的请求。但是，服务器在响应 HEAD 请求时不会回传资源的内容部分，即：响应主体。这样，我们可以不传输全部内容的情况下，就可以获取服务器的响应头信息。HEAD 方法常被用于客户端查看服务器的性能。

    **POST**

    POST 请求会 向指定资源提交数据，请求服务器进行处理，如：表单数据提交、文件上传等，请求数据会被包含在请求体中。POST 方法是非幂等的方法，因为这个请求可能会创建新的资源或/和修改现有资源。

    **PUT**
    PUT 请求会身向指定资源位置上传其最新内容，PUT 方法是幂等的方法。通过该方法客户端可以将指定资源的最新数据传送给服务器取代指定的资源的内容。

    **DELETE**
    DELETE 请求用于请求服务器删除所请求 URI（统一资源标识符，Uniform Resource Identifier）所标识的资源。DELETE 请求后指定资源会被删除，DELETE 方法也是幂等的。

    **CONNECT**
    CONNECT 方法是 HTTP/1.1 协议预留的，能够将连接改为管道方式的代理服务器。通常用于 SSL 加密服务器的链接与非加密的 HTTP 代理服务器的通信。

    **OPTIONS**
    OPTIONS 请求与 HEAD 类似，一般也是用于客户端查看服务器的性能。 这个方法会请求服务器返回该资源所支持的所有 HTTP 请求方法，该方法会用'\*'来代替资源名称，向服务器发送 OPTIONS 请求，可以测试服务器功能是否正常。JavaScript 的 XMLHttpRequest 对象进行 CORS 跨域资源共享时，就是使用 OPTIONS 方法发送嗅探请求，以判断是否有对指定资源的访问权限。 允许

    **TRACE**
    TRACE 请求服务器回显其收到的请求信息，该方法主要用于 HTTP 请求的测试或诊断。

### JS

#### null 与 undefined 区别

相同点:

- 在 `if`判断语句中,值都默认为 `false`
- 大体上两者都是代表**无**,具体看差异

差异:

- `null`转为数字类型值为 0,而`undefined`转为数字类型为 `NaN(Not a Number)` (Number.parseInt()都是 NaN)
- `undefined`是代表调用一个值而该值却没有赋值,这时候默认则为`undefined`
- `null`是一个很特殊的对象,最为常见的一个用法就是作为参数传入(说明该参数不是对象)
- 设置为`null`的变量或者对象会被内存收集器回收

非严格相等

`ToNumber(A)` 尝试在比较前将参数 A 转换为数字，这与 +A（单目运算符+）的效果相同。`ToPrimitive(A)`通过尝试依次调用 A 的`A.toString()` 和 `A.valueOf()` 方法，将参数 A 转换为原始值（Primitive）

![52187529113](C:\Users\mwindson\AppData\Local\Temp\1521875291134.png)

`falsy value` : 0 , NaN,"", false, null , undefined

#### jsonp

```
/**
 * 获取随机字符串,用于拼接
 * @param {string} prefix [前导名字]
 * @param {number} num  [字符串长度]
 */
function getRandomName (prefix, num) {
	return prefix + Math.random().toString(36).replace(/[^a-z]+/g, '').substr(0, num)
}

/**
 * 创建script标签
 * @param {请求路径} url
 */
function createScript (url) {
	const script = document.createElement('script')
	script.setAttribute('type', 'text/javascript')
	script.setAttribute('src', url)
	script.async = true
	return script
}

/**
 * 实现请求
 * @param {路径} url
 */
function jsonp (url) {
	return new Promise((resolve, reject) => {
		const cbName = getRandomName('callback')
		window[cbName] = function (data) {
			resolve(data)
		}

		url += url.indexOf('?') > -1 ? '&' : '?'
		const script = createScript(`${url}callback=${cbName}`)

		script.onload = function () {
			script.onload = null
			if (script.parentNode) {
				script.parentNode.removeChild(script)
			}
			window[cbName] = null
		}

		script.onerror = function () {
			reject()
		}

		document.getElementsByTagName('head')[0].appendChild(script)
	})
}
```

### ES6

`Array.from` 方法用于将两类对象转为真正的数组：类似数组的对象（array-like object）和可遍历（iterable）的对象（包括 ES6 新增的数据结构 Set 和 Map）

`Array.of`方法用于将一组值，转换为数组

- **es5 继承 (寄生组合继承)**

  ```javascript
  function ParentClass(name) {
    this.name = name
  }
  ParentClass.prototype.sayHello = function() {
    console.log("I'm parent!" + this.name)
  }
  function SubClass(name, age) {
    //  若是要多个参数可以用apply 结合 ...解构
    //  调用父类的构造函数
    ParentClass.call(this, name)
    // ....
  }
  SubClass.prototype = Object.create(ParentClass.prototype)
  SubClass.prototype.sayChildHello = function(name) {
    console.log("I'm child " + this.name)
  }
  ```

- **静态方法**

  - 方法不能给 this 引用,可以给类直接引用
  - 静态不可以给实例调用,比如 `let a = new ParentClass => a.sayHello()` 会抛出异常
  - 父类静态方法,子类非`static`方法没法覆盖父类
  - 静态方法可以给子类继承
  - 静态属性可以继承也可以被修改

- **私有变量**

  - 人为命名区分
  - 利用闭包
  - weakMap 可以避免内存泄露,当没有被值引用的时候会自动给内存寄存器回收

- **Q: 谈谈你对 TCP 的理解;**
  挥手时发送报文表示自己不在发送数据，但扔接受数据

  > Q: TCP 是在哪个 OSI 的哪个层!通讯过程是全双工还是半双工(单工)?
  >
  > A: 传输层,全双工
  >
  > Q: TCP 的通讯的过程是怎么样的!
  >
  > A: 整个过程是三次握手,四次挥手..
  >
  > Q: 你说的没错,说说整个过程如何?
  >
  > A: 举个栗子,我把 TCP 比做两个人用对讲机沟通(大白话)..三次握手就是.A1(吼叫方,客户端)想要呼叫 A2(控制室的某某,服务端)..
  >
  > A1 对着对讲机说"over over ,听到请回答"(第一次,请求应答) ...
  >
  > A2 收到回应"收到收到,你说"(第二次,确认应答)
  >
  > A1 开始巴拉巴拉个不停而 A2 没拒绝(第三次,通讯建立)
  >
  > ***
  >
  > 而四次挥手则是两者确认互相倾述完毕的过程..
  >
  > A1 说:"控制室,报告完毕了"(第一次挥手)
  >
  > A2 说:"知道了...那么你废话说完就好好听我指挥....巴拉巴拉.."(第二次挥手)
  >
  > A1 此时等待控制室说完毕,而控制室等回应(第三次挥手)
  >
  > 等到 A1 回馈控制室确认都知道完毕了..(第四次挥手)...

  **为什么建立连接是三次握手，而关闭连接却是四次挥手呢？**

  这是因为服务端在 LISTEN 状态下，收到建立连接请求的 SYN 报文后，把 ACK 和 SYN 放在一个报文里发送给客户端。而关闭连接时，当收到对方的 FIN 报文时，仅仅表示对方不再发送数据了但是还能接收数据，己方也未必全部数据都发送给对方了，所以己方可以立即 close，也可以发送一些数据给对方后，再发送 FIN 报文给对方来表示同意现在关闭连接，因此，己方 ACK 和 FIN 一般都会分开发送。

- `OSI` 七层涵盖:物理层,数据链路层,网络层（IP）,传输层（TCP、UDP）,会话层,表示层,应用层（DNS，HTTP）;

- `DNS` 属于应用层协议

  1.  优先读取浏览器缓存
  2.  其次系统的缓存
  3.  都没有的情况下,找本地`hosts`文件(比如你写了映射关系优先寻找)
  4.  再没有的情况找最近的域名解析服务器
  5.  再没有则扩大访问,最终找到根服务器,还是没有就失败了..

* **call apply bind 区别**

  call 需要把参数按顺序传递进去（需要知道参数数量），而 apply 则是把参数放在数组里（不知道参数数量）

  bind()方法会创建一个新函数，称为绑定函数，当调用这个绑定函数时，绑定函数会以创建它时传入 bind()方法的第一个参数作为 this，传入 bind() 方法的第二个以及以后的参数加上绑定函数运行时本身的参数按照顺序作为原函数的参数来调用原函数。

  call 和 apply 都是对函数的直接调用，而 bind 方法返回的仍然是一个函数，因此后面还需要()来进行调用才可以。

* Promise catch 返回一个 promise(undefined,onRejected)

  catch 之后 then 也会执行

* **标记清除**

  这是 javascript 中最常用的垃圾回收方式。当变量进入执行环境是，就标记这个变量为“进入环境”。从逻辑上讲，永远不能释放进入环境的变量所占用的内存，因为只要执行流进入相应的环境，就可能会用到他们。当变量离开环境时，则将其标记为“离开环境”。

  变量设置为 null，则会在下次进行垃圾回收

* new 关键字就意味着一次内存分配。在初始化的时候新建对象，在后续中尽量多重用这些创建好的对象。

  - 第一步：创建一个新对象
  - 第二步：将构造函数的作用域赋给新对象（this）
  - 第三步：执行构造函数中的代码（为新对象添加属性）
  - 第四部：返回新的对象

  另外还有以下三种内存分配表达式（可能不像 new 关键字那么明显了）：

  - {} （创建一个新对象）
  - [] （创建一个新数组）
  - function() {…}

* **异常捕获**

  - `try catch`

  - `promise` 中的`catch` 和`reject`

    ```javascript
    throw Error('永远无法被捕获') //该错误信息无法在catch中捕获
    ```

  - `window.onerror`

    `window.onerror`包含了`try...catch`的优势，而`try...catch`无法捕获的语法错误和全局异常处理，`window.onerror`都可以做到。不过，由于是全局监测，就会统计到浏览器插件中的 js 异常。

  - **js 原生错误类型**

    - SyntaxError 解析代码时发生的语法错误。
    - ReferenceError 引用一个不存在的变量时发生的错误。
    - RangeError 当一个值超出有效范围时发生的错误。
    - TypeError 是变量或参数不是预期类型时发生的错误。

* 浅拷贝：引用复制和 Object.assign

  深拷贝：

  - 利用 Array 的 slice 和 concat 方法

  - Json 的 parse 和 stringify

  - 实现
    ```javascript
    function deepClone(initalObj, finalObj) {
      var obj = finalObj || {}
      for (var i in initalObj) {
        // 遍历原有对象属性
        var prop = initalObj[i] // 避免相互引用对象导致死循环，如initalObj.a = initalObj的情况
        if (prop === obj) {
          continue
        }
        if (typeof prop === 'object') {
          obj[i] = prop.constructor === Array ? [] : Object.create(prop)
        } else {
          obj[i] = prop
        }
      }
      return obj
    }
    ```

* resize 和 scroll 事件的性能优化

  resize: debounce

  ```javascript
  var debounce = function(idle, action) {
    var last
    return function() {
      var ctx = this,
        args = arguments
      clearTimeout(last) // 将上一次的定时事件取消
      last = setTimeout(function() {
        action.apply(ctx, args)
      }, idle)
    }
  }
  ```

  ​
  scroll：throttle

  ```javascript
  var throttle = function(delay, action) {
    var last = 0
    return function() {
      var curr = +new Date() // performance.now()更好
      if (curr - last > delay) {
        action.apply(this, arguments)
        last = curr
      }
    }
  }
  ```

  ​

* Object.create()的 polyfill

  ```javascript
  function pureObject(obj) {
    //定义了一个临时构造函数
    function F() {}
    //将这个临时构造函数的原型指向了传入进来的对象。
    F.prototype = obj
    //返回这个构造函数的一个实例。该实例拥有obj的所有属性和方法。
    //因为该实例的原型是obj对象。
    return new F()
  }
  ```

- [x] React

  - 生命周期

    当树被卸载，旧的 DOM 节点将被销毁。组件实例会调用 `componentWillUnmount()`。当构建一棵新树，新的 DOM 节点被插入到 DOM 中。组件实例将依次调用 `componentWillMount()`和 `componentDidMount()`。任何与旧树有关的状态都将丢弃。

    当组件更新时，实例仍保持一致，以让状态能够在渲染之间保留。React 通过更新底层组件实例的 props 来产生新元素，并在底层实例上依次调用 `componentWillReceiveProps()` 和 `componentWillUpdate()` 方法。

    `componentWillReceiveProps`当父组件变化时，子组件会调用

  - `Diff 算法`

    见 https://reactjs.org/docs/reconciliation.html

    **三个策略**

    1.  经验：Web UI 中 DOM 节点跨层级的移动特点少；

        对 VDOM 的树比较时，只进行分层比较，同一层次的节点比较

    2.  经验：相同类的组件会生成相似的树形结构，不同的会生成不同的

        - 同一类型的组件，保持相同的底层 DOM 节点，并仅更新变化的属性。
        - 不是同一类，替换所有子节点
        - 可以用 shouldComponentUpdate（）来判断否需要 diff

    3.  同一层的一组子节点，可以用唯一的 id 区分相同子节点加上 key 作为标识

  - React 事件

    在 React 中不会把所有的事件处理器绑定到相应的真实的 DOM 节点上，而是使用一个统一的事件监听器，把所有的事件绑定在最外层。当事件发生的时候，首先被这个统一的事件监听器处理，随后找到真正的事件处理函数进行调用，这样是为了提高效率，这是因为在 UI 系统中，事件处理器越多，那么占据的内存就越大，React 的做法是将其简化为一个，这样就大大提高了效率。在之前开发者需要为了优化性能需要自己来优化自己的事件处理器的代码，现在 React 帮助你完成了这些工作。

  - 性能优化

    - 纯函数

    - PureRender（PureComponent，如果之前 props 与当前 props 浅比较相同时，不会 render）

      用 Immutable.is 更简单（利用两个对象的 hashcode 和 valueof）

    - 动态子组件设置 key

  - Immutable

    节省内存，结构共享，不同对象的相同引用对象，相等

    不可变，降低复杂度和不可预测性

    函数式编程，链式 api

- [x] Flux

  `dispatcher` 分发 view 传入的数据

  `store` 存储数据，根据 action 的 type 来修改数据（与 Redux 不同，会存在多个 store）

  `view` 视图组件如 React，修改数据时要 dispatcher 一个 action

  `controller view` store 与 view 层进行绑定的定义与方式

- [x] Redux

  Redux 的三大原则

  - 数据 store 唯一
  - 状态都是只读的
  - 纯函数实现 state 改变

  Redux 设计模型：单例模式（store），中介者模式，装饰者模式，订阅者模式

  _`redux-thunk`_ 的主要思想是扩展 action，使得 action 从一个对象变成一个函数，getState 和 dispatch 来进行读写

  _`redux-thunk`_ 的缺点：

  （1）action 虽然扩展了，但因此变得复杂，后期可维护性降低；

  （2）thunks 内部测试逻辑比较困难，需要 mock 所有的触发函数；

  （3）协调并发任务比较困难，当自己的 action 调用了别人的 action，别人的 action 发生改动，则需要自己主动修改；

  （4）业务逻辑会散布在不同的地方：启动的模块，组件以及 thunks 内部。

  `redux-saga` 采用 Generator 函数来 yield Effects（包含指令的文本对象）

  在 _redux-saga_ 中，UI 组件自身从来不会触发任务，它们总是会 `dispatch` 一个 action 来通知在 UI 中哪些地方发生了改变，而不需要对 action 进行修改。

  **worker saga**
  做所有的工作，如调用 API，进行异步请求，并且获得返回结果

  **watcher saga**
  监听被 dispatch 的 actions，当接收到 action 或者知道其被触发时，调用 worker saga 执行任务

  **root saga**
  立即启动 sagas 的唯一入口

- [x] Vue

  - Vue 原理

    采用数据劫持结合发布者-订阅者模式的方式，利用 dependence 来收集数据变化，用`Object.defineProperty` 对数据的 setter 与 getter 方法进行修改进行响应

  - https://github.com/DMQ/mvvm

    - 数据监听器 Observer，能够对数据对象的所有属性进行监听，如有变动可拿到最新值并通知订阅者
    - 指令解析器 Compile，对每个元素节点的指令进行扫描和解析，根据指令模板替换数据，以及绑定相应的更新函数
    - Watcher，作为连接 Observer 和 Compile 的桥梁，能够订阅并收到每个属性变动的通知，执行指令绑定的相应回调函数，从而更新视图

    ![img](https://github.com/DMQ/mvvm/raw/master/img/2.png)


- [x] koa

  洋葱圈模型

  中间件：普通函数与 async 异步函数

  - `ctx.cookies.get(name, [options])` 读取上下文请求中的 cookie
  - `ctx.cookies.set(name, value, [options])` 在上下文中写入 cookie
  - session 没有原生操作，如果 session 数据量很小，可以直接存在内存中 `koa-session-minimal`
  - 如果 session 数据量很大，则需要存储介质存放 session 数据 `koa-mysql-session`

* [x] Babel

  `ES6代码输入 ==》 babylon进行解析 ==》 得到AST ==》 plugin用babel-traverse对AST树进行遍历转译 ==》 得到新的AST树 ==》 用babel-generator通过AST树生成ES5代码`

  `babel-preset-env` 允许你指定一个代码执行环境，并且只编译该环境缺少的特性。

  `babel-polyfill`

  babel 预设可以编译几乎所有的 JavaScript 新语法，但是对于 API 却不能解决，解决这个问题 babel 用的是 babel-polyfill (它有 core-js 和 regenerator 两部分构成)。
  `babel-plugin-tranform-classes`// 解决 ES6 类（class）的兼容性

* [x] code split

  - webpack
    - 入口起点：使用 entry 配置手动地分离代码。
    - 防止重复：使用 CommonsChunkPlugin 去重和分离 chunk。
    - 动态导入：通过模块的内联函数调用来分离代码。
  - React-Router -- 访问到路由才加载加了
    - `getChildRoutes`
    - `getIndexRoute`
    - `getComponents`

* [x] 静态资源的更新

  1.  如果先覆盖 index.html，后覆盖 a.js，用户在这个时间间隙访问，会得到新的 index.html 配合旧的 a.js 的情况，从而出现错误的页面。
  2.  如果先覆盖 a.js，后覆盖 index.html，用户在这个间隙访问，会得到旧的 index.html 配合新的 a.js 的情况，从而也出现了错误的页面。

  使用基于文件内容的 hash 版本冗余机制


**repaint** —— 重绘

当一个 DOM 元素的外观发生改变时（例如：outline, visibility, color, background color 等改变）， 浏览器会根据元素的新样式属性重新绘制，使元素呈现新的外观，这个过程叫做 **重绘**, **它不会影响到布局**。重绘的性能代价是高昂的，因为浏览器必须验证 DOM 树上其他节点元素的可见性。

##### 什么情况只发生 repaint（重绘）

- 仅修改 DOM 元素的 **颜色属性**（color, background-color, border-color …）或 **visibility、outline 属性**，因为不会改变布局 所以只发生 repaint

**reflow** —— 回流

可以理解为渲染树需要重新计算，并根据计算的结果 将元素渲染到它所在屏幕上的确切坐标，回流影响到部分（或整个）页面的布局，一个元素回流会导致它所有的子元素、祖先元素、兄弟元素发生回流。

##### 哪些情况会发生 reflow（回流）

- 使用**JS 增加、删除、或修改 DOM 节点**（包括移除或增加样式表）

- 设置元素的**内联样式** 即 style 属性

- 修改元素 **class** 属性

- 更改字体

- CSS 中修改 **display** 属性

- 网页上内容发生变化，例如在 **input** 或 **textarea** 里输入文字

- 计算 offsetWidth 和 offsetHeight 属性

- 缩放（Resize）或滚动浏览器窗口（移动端不存在缩放浏览器窗口的情况）

- 另外，在 webkit 中，当元素应用了 position 为 fixed 或 absolute 时，修改它们的其他 CSS 样式 也只会发生回流（webkit 会作为 layout 操作，其他浏览器只发生重绘）

#### 一些有关减少或避免 reflow（回流）的建议

##### **操作元素样式的技巧：**

- 避免同时设置多个元素的内联样式（style 属性）
- 实现动画时，最好应用在 position 为 fixed 或 absolute 的元素上
- 避免使用 table 布局
- 不要使用 CSS JavaScript 表达式（例如：color: expression((new Date()).getHours()%2 ? “#0091ea” : “#00b8d4” )

**修改 DOM 的技巧：**

- 如果想用 JS 修改元素的样式，最好通过改变元素的 class 名，并尽可能在 DOM 树最末端的节点上修改（例如可以想办法只修改元素子节点上的 class）

- 不要多次修改 DOM，可以使用 document.createDocumentFragment() 把要改的 DOM 节点缓存起来 在内部修改，再一次性添加进 HTML 中

- 将要修改的 DOM 节点设置 display:none，会有一次 repaint，接着可以多次修改，修改完后再设置为 display:block

​

### 常见的网页性能优化方法

- 减少 HTTP 请求

使用雪碧图、内联图片，合并脚本和样式表。

- 使用内容分发网络（CDN）
- 添加 Expires 头
- 压缩组件

压缩样式表和脚本，开启 gzip 压缩大概减少 70%的大小

- 样式表放在顶部
- 将脚本放在底部
- 避免 CSS 表达式
- 使用外部 JavaScript 和 CSS
- 减少 DNS 查找
- 精简 JavaScript
- 避免重定向

### 进程和线程的区别？

一个程序至少有一个进程，一个进程至少有一个线程，资源分配给进程，同一个进程下的所有线程共享该进程的所有资源。

### SSL 加密

它采用了 RC4、MD5 以及 RSA 等加密算法，使用 40 位的[密钥](https://baike.baidu.com/item/%E5%AF%86%E9%92%A5)，适用于商业信息的加密。

#### GET 与 POST 区别

GET 后退按钮/刷新无害，POST 数据会被重新提交（浏览器应该告知用户数据会被重新提交）。
GET 书签可收藏，POST 为书签不可收藏。
GET 能被缓存，POST 不能缓存 。
GET 编码类型 application/x-www-form-url，POST 编码类型 encodedapplication/x-www-form-urlencoded 或 multipart/form-data。为二进制数据使用多重编码。
GET 历史参数保留在浏览器历史中。POST 参数不会保存在浏览器历史中。
GET 对数据长度有限制，当发送数据时，GET 方法向 URL 添加数据；URL 的长度是受限制的（URL 的最大长度是 2048 个字符）。POST 无限制。
GET 只允许 ASCII 字符。POST 没有限制。也允许二进制数据。与 POST 相比，GET 的安全性较差，因为所发送的数据是 URL 的一部分。在发送密码或其他敏感信息时绝不要使用 GET ！POST 比 GET 更安全，因为参数不会被保存在浏览器历史或 web 服务器日志中。
GET 的数据在 URL 中对所有人都是可见的。POST 的数据不会显示在 URL 中。

**GET 产生一个 TCP 数据包；POST 产生两个 TCP 数据包。**

### CommonJS

NodeJS 就采用了 CommonJS。是这样加载模块：

```JavaScript
var clock = require('clock');
clock.start();
```

这种写法适合服务端，因为在服务器读取模块都是在本地磁盘，加载速度很快

### AMD

AMD，即 (Asynchronous Module Definition)，这种规范是异步的加载模块，requireJs 应用了这一规范。先定义所有依赖，然后在加载完成后的回调函数中执行，开始就把所有依赖写出来是不符合书写的逻辑顺序的。

```
 1.我们在使用requireJS时，都会把所有的js交给requireJS来管理，也就是我们的页面上只引入一个require.js，把data-main指向我们的main.js。

 2.通过我们在main.js里面定义的require方法或者define方法，requireJS会把这些依赖和回调方法都用一个数据结构保存起来。

 3.当页面加载时，requireJS会根据这些依赖预先把需要的js通过document.createElement的方法引入到dom中，这样，被引入dom中的script便会运行。

 4.由于我们依赖的js也是要按照requireJS的规范来写的，所以他们也会有define或者require方法，同样类似第二步这样循环向上查找依赖，同样会把他们村起来。

 5.当我们的js里需要用到依赖所返回的结果时(通常是一个key value类型的object),requireJS便会把之前那个保存回调方法的数据结构里面的方法拿出来并且运行，然后把结果给需要依赖的方法。

 6.以上就是一个简单的流程。
```

### CMD

CMD (Common Module Definition), 是 seajs 推崇的规范，CMD 则是依赖就近，用的时候再 require。

AMD 和 CMD 最大的区别是对依赖模块的执行时机处理不同，而不是加载的时机或者方式不同，二者皆为异步加载模块。AMD 依赖前置，js 可以方便知道依赖模块是谁，立即加载；而 CMD 就近依赖，需要使用把模块变为字符串解析一遍才知道依赖了那些模块。

### es6

CommonJS 模块输出的是一个值的拷贝，ES6 模块输出的是值的引用（会改变引入的值）。

CommonJS 模块是运行时加载，ES6 模块是编译时输出接口。

#### UMD

兼容了 AMD 和 CommonJS，同时还支持老式的“全局”变量规范

### 什么是事件循环（EVENT LOOP）？

js 是单线程的，是指 js 执行引擎是单线程的，除了这个单线程，还有一个 任务队列，在执行 js 代码的过程中，执行引擎遇到注册的延时方法，如定时器，DOM 事件， 会将这些方法交给相应的浏览器模块处理，当这些延时方法有触发条件去触发的时候， 这些延时方法会被添加至任务队列，而这些任务队列中的方法只有 js 的主线程空闲了才会执行， 这也就是说我们常常用的定时器定的时间参数只是一个触发条件，具体多少时间后执行其实还需要看 js 主线程空闲与否

一个事件循环(event loop)会有一个或多个任务队列(task queue) task queue 就是 macrotask queue

每一个 event loop 都有一个 microtask queue

microtask queue> macrotask queue

一个任务 task 可以放入 macrotask queue 也可以放入 microtask queue 中

当一个 task 被放入队列 queue(macro 或 micro) 那这个 task 就可以被立即执行了

task

Marco-task：定时器， I/O，UI 渲染

mirco-stack:promise 和 mutation observer

### 原生 JS 操作 DOM 的方法有哪些？

获取节点的方法

getElementById、getElementsByClassName、getElementsByTagName、 getElementsByName、querySelector、querySelectorAll

对元素属性进行操作

getAttribute、 setAttribute、removeAttribute 方法

对节点进行增删改

appendChild、insertBefore、replaceChild、removeChild、 createElement 等

### JavaScript 严格模式下有哪些不同？

- 不允许不使用 var 关键字去创建全局变量，抛出 ReferenceError
- 不允许对变量使用 delete 操作符，抛 ReferenceError
- 不可对对象的只读属性赋值，不可对对象的不可配置属性使用 delete 操作符，不可为不可拓展的对象添加属性，均抛 TypeError
- 对象属性名必须唯一
- 函数中不可有重名参数
- 在函数内部对修改参数不会反映到 arguments 中
- 淘汰 arguments.callee 和 arguments.caller
- 不可在 if 内部声明函数
- 抛弃 with 语句

##### addEventListener 有哪些参数？

有三个参数，第一个是事件的类型，第二个是事件的回调函数，第三个是一个表示事件是冒泡阶段还是捕获阶段捕获的布尔值，true 表示捕获，false 表示冒泡

##### jsonp 的实现思路

创建一个 script 标签，设置 src 为相应的 url，在 url 之后添加相应的 callback，格式类似于 url?callback=xxx

##### 将静态资源放在其他域名的目的是什么？

这样做的主要目的是在请求这些静态资源的时候不会发送 cookie，节省了流量，需要注意的是 cookie 是会发送给子域名的（二级域名），所以这些静态资源是不会放在子域名下的， 而是单独放在一个单独的主域名下。同时还有一个原因就是浏览器对于一个域名会有请求数的限制，这种方法可以方便做 CDN。

##### 前端如何实现 PV 和 UV 的统计

​ PV(访问量)：Page View, 即页面浏览量或点击量，用户每次刷新即被计算一次。

UV(独立访客)：Unique Visitor,一般使用 cookie 标记,访问您网站的一台电脑客户端(比如一台电脑开多个浏览器访问则为多个 UV)为一个访客，00:00-24:00 内相同的客户端只会被计算一次。

IP(独立 IP)：指独立 IP 数。00:00-24:00 内相同 IP 地址之被计算一次(多台电脑可能共用一个 ip)。

##### 实现深拷贝函数

对于非引用值类型的数值，直接赋值，而对于引用值类型（object）还需要再次遍历，递归赋值。

##### ajax 的 readyState 有哪几个状态，含义分别是什么？

ajax 的 readyState 共有 5 个状态，分别是 0-4，0 代表还没调用 open 方法，1 代表的是未调用 send 方法，也就是还没发送数据给服务器，2 代表的是还没有接收到响应，3 代表的是开始接收到了部分数据，4 代表的是接收完成

#### ES7 特性：

1.`Array.prototype.includes`
2.Exponentiation Operator(求冥运算) —— 2\*\*3=8

#### ES8 特性：

##### 字符串填充

- 此部分将两个函数添加到 String 对象：padStart＆padEnd。

- `Object.values 和 Object.entries`

- `Object.getOwnPropertyDescriptors`

- `async` `await`

- 共享内存和原子

##### Service Worker

- 它是一种 JavaScript 工作线程，无法直接访问 DOM。 服务工作线程通过响应 postMessage 接口发送的消息来与其控制的页面通信，页面可在必要时对 DOM 执行操作。
- 服务工作线程是一种可编程网络代理，让您能够控制页面所发送网络请求的处理方式。
- 它在不用时会被中止，并在下次有需要时重启，因此，您不能依赖于服务工作线程的 onfetch 和 onmessage 处理程序中的全局状态。如果存在您需要持续保存并在重启后加以重用的信息，服务工作线程可以访问 IndexedDB API。
- 服务工作线程广泛地利用了 promise

##### Canvas 优化

- 分层 Canvas
- 离屏渲染
- 避免无用的绘制
- webworker 和拆分任务

##### 职责链模式？

将一个流程进行分解，让这个流程在多个对象中进行传递，由最后一个对象完成这个流程。通过职责链模式能够将流程进行分解，从而解耦。

##### CSS3 的新特性

- 在布局方面新增了 flex 布局
- 在选择器方面新增了例如:first-of-type,nth-child 等选择器
- 在盒模型方面添加了 box-sizing 来改变盒模型
- 在动画方面增加了 animation、2d 变换、3d 变换等
- 在颜色方面添加透明、rgba 等
- 在字体方面 允许嵌入字体和设置字体阴影,
- 盒子的阴影
- 关键的媒体查询。

##### CSS 硬件加速

​ 触发硬件加速的 CSS 属性有 transform、opacity、filter，为了避免 2D 动画在 开始和结束的时候的 repaint 操作，一般使用 tranform:translateZ(0)

##### CSS3 动画如何实现暂停？

css3 动画可以通过设置 animation-play-state 属性为 paused 来设置这个动画暂停。

#### 简单请求

- 请求方法是如下之一：
  - GET
  - HEAD
  - POST
- 所有的 Header 都在如下列表中：
  - Cache-Control
  - Content-Language
  - Content-Type
  - Expires
  - Last-Modified
  - Pragma

#### 预检请求

会附带一些关于接下来的请求的信息给服务器，主要有以下几种：

Origin：请求的源域信息
Access-Control-Request-Method：接下来的请求类型，如 POST、GET 等
Access-Control-Request-Headers：接下来的请求中包含的用户显式设置的 Header 列表

```java
// 后台处理
response.setHeader('Access-Control-Allow-Origin', '*')
response.setHeader('Access-Control-Allow-Methods', 'POST')
response.setHeader('Access-Control-Allow-Headers', 'x-requested-with,content-type')
response.addHeader('Access-Control-Allow-Credentials', 'true')
```

（2）利用 JSONP 实现跨越

对于较老的浏览器，它们往往不支持 CORS，因此使用 JSONP 进行跨域也是很常见的一种方式。

我们知道在网页中通过`<script>`元素的 src 指定加载目标脚本时是不受同源策略的影响的，因此可以使用它们从其他服务器请求数据，这种利用`<script>`元素作为 Ajax 传输的技术就称为 JSONP。

JSONP 也存在一些弊端。首先 JSONP 支持 GET 不支持 POST 方法，另外使用`<script>`元素进行 Ajax 请求，这意味着允许 Web 页面可以执行远程服务器发送过来的任何 JavaScript 代码，因此对于不信任的服务器，不应该采用该技术。

（3）利用 window.name 进行跨域

window 对象有个 name 属性，该属性有个特征：即在一个窗口(window)的生命周期内,窗口载入的所有的页面都是共享一个 window.name 的，每个页面对 window.name 都有读写的权限，window.name 是持久存在一个窗口载入过的所有页面中的，并不会因新页面的载入而进行重置，因此可以借助 window.name 在不同源的页面中传递数据。

如 www.a.com/a.html 想要获得 www.b.com/b.html 中的数据,原理如下：

a) 在 b.html 中将数据存储在 window.name 中

b) 在 a.html 中构建一个隐藏（display：none）的 iframe 标签，假设 id 设为 proxy，src 设置为和 a.html 同源即可。

（4) 使用 window.postMessage 进行跨域

这种方式比较简单，在 a 页面中利用 windowObj.postMessage(message, targetOrigin)向目标页面发送信息，而在 b 页面中通过监听 message 事件获取信息。这种方式是在 HTML5 中新增的方法，对于 IE6、IE7 等老版本浏览器无法使用。

##### Restful API

- GET /collection：返回资源对象的列表（数组）
- GET /collection/resource：返回单个资源对象
- POST /collection：返回新生成的资源对象
- PUT /collection/resource：返回完整的资源对象
- PATCH /collection/resource：返回完整的资源对象
- DELETE /collection/resource：返回一个空文档

**何为混合应用 (Hybrid APP) ，与原生 Native 应用相比它的优劣势**

Hybrid APP 是 Native APP 上结合使用了 Web View （Native APP 的模块或称组件，用来加载 Web 资源），采用了 Web 技术的 APP，本质上属于原生应用（APP 外壳）。

优势：

兼容性良好，“一次开发，多处运行”，能够减少原生 APP 开发在多平台带来的问题代码移植性高

开发者社区活跃，能够及时应用最新适合的 Web 技术来解决问题，提高用户体验

APP 更加轻便，内容更新方便，部分更新不用从 APP Store 下载劣势：

性能：相对不如 Native APP 性能良好、体验流畅
Web 技术在 APP 中操作权限有限，需要 APP 同步支持

#### 移动端布局

1.  flex 布局
2.  百分比布局与 media query
3.  Rem 适配 + vw
4.  js 处理获取手机 dpr 参数，然后动态生成 viewpoint，动态计算 height 与 width
5.  获取手机物理像素宽度，分成 10 份，每一份的宽度即是 rem 的尺寸
6.  根据设计稿的尺寸（px）分三种情况进行处理，采用 px + rem 布局

### es5 原型与 class

- es5 的每个对象的`__proto__`属性指向构造函数的 prototype 属性；
- Class 同时具有 prototype 属性和`__proto__`属性
- 子类的`__proto__`继承构造函数，指向父类
- 子类 prototype 属性的`__proto__`继承方法，指向父类的`prototype`属性
- Class 没有变量提升，是严格模式
- class 可以加 static 实现静态方法，静态属性必须按 es5 的办法
- new 的时候用 new.target 判断构造函数，因此必须用 new 来调用

#### Vue 原理

当你把一个普通的 JavaScript 对象传给 Vue 实例的 `data` 选项，Vue 将遍历此对象所有的属性，并使用 [Object.defineProperty](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty) 把这些属性全部转为 getter/setter。Object.defineProperty 是 ES5 中一个无法 shim 的特性，这也就是为什么 Vue 不支持 IE8 以及更低版本浏览器的原因。

这些 getter/setter 对用户来说是不可见的，但是在内部它们让 Vue 追踪依赖，在属性被访问和修改时通知变化。这里需要注意的问题是浏览器控制台在打印数据对象时 getter/setter 的格式化并不同，所以你可能需要安装 [vue-devtools](https://github.com/vuejs/vue-devtools) 来获取更加友好的检查接口。

每个组件实例都有相应的 **watcher** 实例对象，它会在组件渲染的过程中把属性记录为依赖，之后当依赖项的 `setter` 被调用时，会通知 `watcher` 重新计算，从而致使它关联的组件得以更新。

![data](https://cn.vuejs.org/images/data.png)

Vue **异步**执行 DOM 更新。只要观察到数据变化，Vue 将开启一个队列，并缓冲在同一事件循环中发生的所有数据改变。如果同一个 watcher 被多次触发，只会被推入到队列中一次。这种在缓冲时去除重复数据对于避免不必要的计算和 DOM 操作上非常重要。然后，在下一个的事件循环“tick”中，Vue 刷新队列并执行实际 (已去重的) 工作。Vue 在内部尝试对异步队列使用原生的 `Promise.then` 和 `MessageChannel`，如果执行环境不支持，会采用 `setTimeout(fn, 0)` 代替。

# web 测试

1.  明确测试目的
2.  并发用户数
3.  最耗资源的功能
4.  最频繁使用功能和访问的页面
5.  网络、设备因素
6.  一些压力测试工具
7.  js 功能测试：Jtest ，snapshot 快照测试
8.  组件：storybook

![img](https://images0.cnblogs.com/blog/512692/201304/12095757-775cf861406644bfad60ff2763f499e4.png)

**禁止 js 操作 Cookie**

服务端设置了 http-only 属性的 Cookie，客户端 JS 无法读取，更别说更改了。

跨域的 Cookie 会存取失败（跨二级域名不包括在内）。

如果浏览器设置了**阻止网站设置任何数据**， 客户端无法接收 Cookie，当然 JS 对 Cookie 的操作会失败。

Cookie 的数量超过最大限制，之前的 Cookie 被自动删除，JS 无法读取到。

Cookie 过期被浏览器自动删除了。

| 进程占有的资源                                      | 线程占有的资源            |
| --------------------------------------------------- | ------------------------- |
| 地址空间 全局变量 打开的文件 子进程 信号量 账户信息 | 栈 寄存器 状态 程序计数器 |

![img](http://hi.csdn.net/attachment/201108/7/0_131271823564Rx.gif)

## 文件名加上 hash 值的原因

另外会设置特别长的 max-age 和过期时间

**文件没有变动**：浏览器不用发起请求直接可以使用缓存文件；
**文件有变化**：由于文件版本号的变更，导致文件名变化，请求的 url 变了，自然文件就更新了。
这样能确保客户端能及时从服务器收取到新修改的文件。通过这样的处理，增长了静态资源，特别是图片资源的缓存时间，避免该资源很快过期，客户端频繁向服务端发起资源请求，服务器再返回 304 响应的情况（有 Last-Modified/Etag）

## 大公司部署

配置超长时间的本地缓存 —— 节省带宽，提高性能

采用内容摘要作为缓存更新依据 —— 精确的缓存控制

静态资源 CDN 部署 —— 优化网络请求

更资源发布路径实现非覆盖式发布 —— 平滑升级

## js 模块加载原理

**原理一：_id 即路径_ 原则。**
通常我们的入口是这样的： require( [ 'a', 'b' ], callback ) 。这里的 'a'、'b' 都是 ModuleId。通过 id 和路径的对应原则，加载器才能知道需要加载的 js 的路径。在这个例子里，就是 baseUrl + 'a.js' 和 baseUrl + 'b.js'。

但 id 和 path 的对应关系并不是永远那么简单，比如在 AMD 规范里就可以通过配置 Paths 来给特定的 id 指配 path。

**原理二：createElement('script') & appendChild**
知道路径之后，就需要去请求。一般是通过 **createElement('script') & appendChild** 去请求。这个大家都知道，不多说。有时候有的加载器也会通过 AJAX 去请求脚本内容。

一般来说，需要给 <script> 设置一个属性用来标识模块 id, 作用后面会提到。

**原理三：document.currentScript**
a.js 里可能是 define( id, factory ) 或者是 define( factory )，后者被称为匿名模块。那么当 define(factory) 被执行的时候，我们怎么知道当前被定义的是哪个模块呢，具体地说，这个匿名模块的实际模块 id 是什么？ 答案是通过 **document.currentScript** 获取当前执行的<script>，然后通过上面给 script 设置的属性来得到模块 id。

需要注意的是，低级浏览器是不支持 currentScript 的，这里需要进行浏览器兼容。**在高级浏览器里面，还可以通过 script.onload 来处理这个事情。**

**原理四：依赖分析**
在继续讲之前，需要先简单介绍下模块的生命周期。模块在被 Define 之后并不是马上可以用了，在你执行它的 factory 方法来生产出最终的 export 之前，你需要保证它的依赖是可用的。那么首先就要先把依赖分析出来。

简单来说，就是通过 toString 这个方法得到 factory 的内容，然后用正则去匹配其中的 require( 'moduleId' )。当然也可以不用正则。

这就是为什么 require( var ); 这种带变量的语句是不被推荐的，因为它会影响依赖分析。如果一定要用变量，可以用 require( [ var ] ) 这种异步加载的方式。

**原理五：递归加载**
在分析出模块的依赖之后，我们需要递归去加载依赖模块

## Webpack 原理

1. 执行脚本 ./bin/webpack.js

2. 使用相关模块获取到配置对象，然后从./lib/webpack.js 中获取到 webpack 来进行编译

3. 调用 lib/WebpackOptionsApply.js 模块的 process 方法来逐一编译 webpack 编译对象的各项

4. 整个个 bundle.js 是一个自执行函数，前 65 行都在定义这个自执行函数，最后传入了一个数组作为参数，因为只有一个 js 文件，这里的数组长度为 1，并且数组里的每一个元素都是一个自执行函数，自执行函数中包含着 index.js 里的内容。

   即整个 bundle.js 文件是一个传入了 包含若干个模块的数组 作为参数，即**传入的 modules 是一个数组**。

5. 在这个 bundle.js 文件中的自执行函数中定义了一个 webpack 打包的函数 \***\*webpack_require\*\***, 这个函数式一个打包的核心函数， 接收一个 moduleId 作为参数，**moduleId 是一个数字，实际上就是整个自执行函数接收的数组参数的 index 值。** 即整个传入的 module 数组，每一个元素都是一个 module，我们为之定义一个特定的 moduleId，**进入函数，首先判断要加载的模块是否已经存在，如果已经存在， 就直接返回 installedModules[moduleId].exports，这样就保证了所有的模块只会被加载一次，而不会被多次加载。 如果说这个模块还没有被加载，那么我们就创建一个 installedModules[moduleId]， 他是一个对象，包括 i 属性（即 moduleId），l 属性（表示这个模块是否已经被加载， 初始化为 false）, exports 属性它的内容是每个模块想要导出的内容， 接下来执行 modules[moduleId].call(module.exports, module, module.exports, **webpack_require**); 函数进行调用，那么这个函数具体是如何执行的呢？ 首先保证在 module.exports 上进行调用这个函数，然后传入了 module 参数，即我们想要调用的这个模块，传入 module.exports ，那么在每一个模块中使用的 module 和 module.exports 就都是属于这个模块的了， 同时再传入 **webpack_require**这样我们就可以在每一个模块中继续使用了加载器了，最后，导出这个模块。 调用完成之后，将 l 设置为 true，表示已经加载，最后导出 module.exports,即导出加载到的模块。**

6. 在自执行函数的末尾我们可以看到这个**自执行函数最终返回了一个 **webpack_require** 调用**，也就是说返回了一个模块，因为**webpck_require**函数本身就会返回一个模块。 并且这个 **webpack_require**调用接收的参数是一个 moduleId ，且指明了其值为 86。 **也就是说入口文件的 moduleId 为 86，** 我们来看一看模块 86 的内容是什么。**即在这个 bundle.js 函数执行之后，实际上得到的第一部分内容是 86 模块的内容**

7. `style-loader` :**将 css 代码添加到 html 中，这个模块中的的核心函数为 addStylesToDom**,内部对所有的 style 进行遍历， 然后添加进入

webpack 的 loader 从右往左，从下往上执行
