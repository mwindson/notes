## ES6

### let const

`let`声明的变量必须在声明后使用，不存在变量提升。

`let`声明的变量会绑定在作用域中，不受外界变量影响，在声明之前变量不可用。

**块级作用域**

外层作用域无法读取内层作用域的变量。

内层作用域可以定义外层作用域的同名变量 。

块级作用域之中，函数声明语句的行为类似于`let`，在块级作用域之外不可引用

### 函数

默认参数，惰性求值

指定了默认值以后，函数的`length`属性，将返回没有指定默认值的参数个数，如果设置了默认值的参数不是尾参数，那么`length`属性也不再计入后面的参数了。

设置了参数的默认值，函数进行声明初始化时，参数会形成一个单独的作用域。

`rest`（...变量名），代替 arguments

### 箭头函数

非箭头函数有自己的`this`，箭头函数没有自己的`this`，而是从自己的作用域链的上一层继承`this`。

由于   箭头函数没有自己的`this`，通过  `call` *或* `apply`  方法调用一个函数时，只能传递参数，第一个参数会被忽略。

### 扩展运算符(...)

将一个数组转为用逗号分隔的**参数序列**。

```javascript
Math.max(...[14, 3, 77])
// 等同于
Math.max(14, 3, 77);
list=[1,2,3]
[a, ...rest] = list // a=1 rest=[2,3]
```

### 可枚举

目前，有四个操作会忽略`enumerable`为`false`的属性。

- `for...in`循环：只遍历对象自身的和继承的可枚举的属性。
- `Object.keys()`：返回对象自身的所有可枚举的属性的键名。
- `JSON.stringify()`：只串行化对象自身的可枚举的属性。
- `Object.assign()`： 忽略`enumerable`为`false`的属性，只拷贝对象自身的可枚举的属性。

### 生成器 generator
